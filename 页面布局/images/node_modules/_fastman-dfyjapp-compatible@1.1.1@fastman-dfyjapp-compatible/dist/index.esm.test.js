import 'fastman2/domman';
import 'fastman2/baseman';
import 'fastman2/mutationobserverman';
import 'fastman2/modalman';
import 'fastman2/pickerman';
import when from 'fastman2/whenman';
import { interceptor, httpClient, errorcodeHandler, timeoutHandler, mimeHandler } from 'fastman2/postman';
import { JSEncrypt, hex, aes, ecb, pkcs7, rc4, md5, utf8 } from 'fastman2/cryptoman';
import store from 'fastman2/storeman';
import 'fastman2/toastman';
import { hideLoading } from 'fastman2/loadingman';
import alert from 'fastman2/alertman';
import { tip } from 'fastman2/tipman';
import 'fastman2/confirmman';
import { onRequest, ready, onBack } from 'fastman2/jsbridgeman';

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var baseConfig = {
  // 网络配置 //
  // 接口请求超时时间(ms)
  timeout: 15000,
  // token存储的localStorage中的key值名称
  tokenKey: '__t__',
  // api接口配置 //
  // @param path  - API网关根路径，对应各环境配置文件(如dev.js、dist.js)中的API网关根路径
  ///////////////////////////////////////////////////////////////
  // 注：为了方便开发，接口可不在该对象中进行定义，没有定义的接口默认指向path
  // 这也意味着各环境配置文件中的path是必须定义的
  ///////////////////////////////////////////////////////////////
  api: {// 'IF00000?': { path: 'path', },
  },
  // 加解密配置列表 //
  // 需要采取加密模式的API列表，如果配置则优先级高于全局XXXPathEncrypt配置，示例：['IF010000', 'IF010001']
  encryptAPIList: [],
  // 不需要采取加密模式的API列表，如果配置则优先级高于全局XXXPathEncrypt配置
  noEncryptAPIList: [],
  // 如果同一功能号同时被配置，将被忽略该配置，使用全局XXXPathEncrypt的配置 //
  // SchemaURL与H5页面之间的映射关系 //
  // 该配置主要用于当某个功能在app端采用客户端方式实现，而在非客户端容器（如微信）则使用对应的映射值来进行路由跳转
  // 举个例子：使用指令dynamicLink对dfyj://dl/myfund?channeltype=1进行跳转，在app端则会进入客户端实现的该功能，而在非客户端容器内则是直接跳转../financing-myfund/index.html
  schemaMapList: [{// 'myfund': '../financing-myfund/index.html',
  }],
  // 全局版本更新管理器
  updateManager: {
    // 更新策略
    // default - 默认策略，提示用户端版本已更新，用户端可取消也可以确认使用新版本
    // quiet - 静默策略，提示用户端版本已更新，用户端不需要做选择
    // forceUpdate - 强制更新策略，提示用户端已更新，用户端只能做出确认选择，一般用在致命bug的场景
    // none - 无感知策略，不提示用户端版本已更新，当用户下次进入时自动更新
    type: "none",
    // 当使用default或quiet策略的提示文本，没有配置会采用默认文案
    text: "当前页面已更新，需要重新打开以使用最新功能",
    // 当使用default策略的确认按钮文本，没有配置会采用默认文案
    okButton: "重新打开",
    // 当使用default策略的取消按钮文本，没有配置会采用默认文案
    cancelButton: "取消",
    // 当使用forceUpdate策略的提示文本，没有配置会采用默认文案
    forceUpdateText: "当前页面已更新，需要重新打开以使用最新功能",
    // 当使用quiet策略的非阻塞提示框消失时间，单位ms，，没有配置会采用默认3500ms
    quietDisappearStayTime: 3500
  }
};
/**
 * 属性继承
 * @type {*}
 * @private
 */

var extend = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      // 源对象中是否存在对象键值
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

// 中台域

var _domain = 'https://zttest.dfzq.com.cn:30013'; // h5资源域

var _resDomain = 'https://obzttest.dfzq.com.cn:30075'; // h5页面域

var _h5Domain = 'https://h5itest1.dfzq.com.cn';
var config = extend({}, baseConfig, {
  // 配置文件对应的环境：开发环境 //
  appEnv: 'sit',
  // 网络配置 //
  // API网关渠道统计(13:微信;12:IOS;17:安卓;24:网厅)
  channel: '24',
  // API网关授权ID
  appId: 'wx.finance.101',
  // API网关域名
  domain: _domain,
  // 资源域
  resDomain: _resDomain,
  // h5页面域
  h5Domain: _h5Domain,
  // API网关端口号
  port: 80,
  // API网关根路径
  path: '/api/gateway?scene=sit',
  // XXXPathEncrypt为该网关下的接口是否需要加密，如果不定义该属性一律认为需要加密
  pathEncrypt: true,
  // XXXPathAlg为该网关下的接口所采用的算法模式，目前支持rc4和aes，如果不定义该属性一律认为使用rc4算法
  // 1:rc4; 2:aes (在XXXPathEncrypt定义为true时算法生效)
  pathAlg: 1,
  // API网关授权RSA公钥
  publicRsaKey: 'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMrEf7fscAuW/EkDIidrFlwEE+tSc9cXmLVafnca8IpHs1MHPCU8r/D8/GYPRs4TJsSmVlNJGiGTAWH0SQabhvWX/x8nxBCw/iGYau+g9P+EO/CAPhQ1MuAKs7Bk7FSw9siGcbwn0UgqRrYou0Rz7SUXzNmS42rHe8Aa+Iui72VwIDAQAB',
  // API网关授权密码
  appSecret: '569f2844061311e68ded005056b807f4',
  // API网关的接口版本号，影响不同版本的API逻辑
  funcVer: '6',
  // 自定义配置 //
  // 下面可以定义针对不同环境的Profile，具体可通过import configuration from 'config'中的configuration.xxx来进行使用
  // 返回到网厅登录页的路径
  loginPath: "https://h5itest1.dfzq.com.cn/html5-wt/wt-login/index.html"
});
var configuration = Object.freeze(extend({}, baseConfig, config));

var rsa = new JSEncrypt(); // 使用公钥对rc4Key进行rsa加密

var publicRsaKey = configuration.publicRsaKey;

if (publicRsaKey == undefined) {
  throw new Error('PublicRsaKey is lost');
}

rsa.setPublicKey(configuration.publicRsaKey); // rc4Key - guid

var guid = function guid() {
  return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
};

var securityInterceptor = interceptor({
  init: function init(config) {
    return config;
  },
  request: function request(_request, config) {
    try {
      // 1.生成key
      // 保证每次请求随机生成128Bit字节，可使用guid的原理来生成不重复字符串
      var rc4Key = guid();
      var rc4KeyEncrypt = rsa.encrypt(rc4Key); // 2.生成content

      config.rc4keyHex = hex.parse(rc4Key);
      var contentEncrypt;
      var api = configuration.api[config.funcNo];

      if (configuration[api.path + 'Alg'] == '2') {
        var aesResult = aes.encrypt(_request.entity, config.rc4keyHex, {
          mode: ecb,
          padding: pkcs7
        });
        contentEncrypt = aesResult.toString();
      } else {
        contentEncrypt = rc4.encrypt(_request.entity, config.rc4keyHex).ciphertext.toString();
      } // 3.生成sign


      var signEncrypt = md5(contentEncrypt + configuration.appSecret); // 包装原始消息体

      _request.rawEntity = _request.entity; // 加密后消息体

      var e = {
        encrypt: configuration[api.path + 'Alg'] || '1',
        key: rc4KeyEncrypt,
        content: contentEncrypt,
        sign: signEncrypt.toString()
      };
      _request.entity = JSON.stringify(e);
      return _request;
    } catch (ex) {
      return when.reject({
        response: _request,
        error: 'encrypterror'
      });
    }
  },
  response: function response(_response, config) {
    try {
      if (_response.error) {
        return _response;
      }

      var responseEntity = _response.entity && _typeof(_response.entity) === 'object' ? _response.entity : JSON.parse(_response.entity); // 进行验签

      var mySign = md5(responseEntity.content + configuration.appSecret).toString();

      if (mySign !== responseEntity.sign) {
        return when.reject({
          response: _response,
          error: 'signerror'
        });
      } // 签名通过后对content进行解密


      var plaintext;

      if (responseEntity.encrypt == '2') {
        var aesResult = aes.decrypt(responseEntity.content, config.rc4keyHex, {
          mode: ecb,
          padding: pkcs7
        });
        plaintext = aesResult.toString(utf8);
      } else {
        var c = {};
        c.ciphertext = hex.parse(responseEntity.content);
        plaintext = rc4.decrypt(c, config.rc4keyHex).toString(utf8);
      } // 包装原始rawEntity


      _response.rawEntity = _response.entity;
      _response.entity = plaintext;

      if (!_response.headers) {
        _response.headers = _response.request.headers;
      }

      return _response;
    } catch (ex) {
      return when.reject({
        response: _response,
        error: 'encrypterror'
      });
    }
  }
});

/*
 * @Author: shenzhiwei
 * @Date: 2019-11-30 13:30:04
 * @Company: orientsec.com.cn
 * @Description: 日志封装
 */
function getNowTime() {
  var date = new Date();

  var _date = date.getDate();

  var hour = date.getHours() < 10 ? "0" + date.getHours() : date.getHours();
  var minute = date.getMinutes() < 10 ? "0" + date.getMinutes() : date.getMinutes();
  var second = date.getSeconds() < 10 ? "0" + date.getSeconds() : date.getSeconds();
  var milliSeconds = date.getMilliseconds();
  var currentTime = hour + ":" + minute + ":" + second + "." + milliSeconds;
  return currentTime;
}

var log = function log(info) {
  console.log(getNowTime() + ": " + (_typeof(info) === 'object' ? JSON.stringify(info) : info));
};

/**
 * Created by dfzq on 2017/3/24.
 */
//     if(window.performance){
//         var now = (window.performance.now() / 1000).toFixed(3);
//         console.info(now + ': ' + message);
//     }else{
//         console.info(message);
//     }
// }

var logInterceptor = interceptor({
  init: function init(config) {
    return config;
  },
  request: function request(_request, config) {
    if (configuration.env !== 'prod') {
      log('{request}->{' + config.funcNo + '}' + JSON.stringify(_request));
    }

    return _request;
  },
  response: function response(_response, config) {
    if (configuration.env !== 'prod') {
      // 深复制一份debug输出对象
      var resp = {};
      resp.entity = _response.entity;
      resp.httpStatus = _response.status;
      log('{response}<-{' + config.funcNo + '}' + JSON.stringify(resp));
    }

    return _response;
  }
});

/**
 * Created by linyiqing on 2017/3/31.
 * 设备检测工具包，用于区分是移动设备还是PC浏览器打开，并且还可以检测是通过我司IOS还是ANDROID的APP打开
 */
function detect(ua, platform) {
  var os = this.os = {},
      browser = this.browser = {},
      webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/),
      android = ua.match(/(Android);?[\s\/]+([\d.]+)?/),
      osx = !!ua.match(/\(Macintosh\; Intel /),
      ipad = ua.match(/(iPad).*OS\s([\d_]+)/),
      ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/),
      iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/),
      webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/),
      win = /Win\d{2}|Windows/.test(platform),
      wp = ua.match(/Windows Phone ([\d.]+)/),
      touchpad = webos && ua.match(/TouchPad/),
      kindle = ua.match(/Kindle\/([\d.]+)/),
      silk = ua.match(/Silk\/([\d._]+)/),
      blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/),
      bb10 = ua.match(/(BB10).*Version\/([\d.]+)/),
      rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/),
      playbook = ua.match(/PlayBook/),
      chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/),
      firefox = ua.match(/Firefox\/([\d.]+)/),
      firefoxos = ua.match(/\((?:Mobile|Tablet); rv:([\d.]+)\).*Firefox\/[\d.]+/),
      ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/[\d](?=[^\?]+).*rv:([0-9.].)/),
      webview = !chrome && ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/),
      safari = webview || ua.match(/Version\/([\d.]+)([^S](Safari)|[^M]*(Mobile)[^S]*(Safari))/);
  if (browser.webkit = !!webkit) browser.version = webkit[1];
  if (android) os.android = true, os.version = android[2];
  if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
  if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
  if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
  if (wp) os.wp = true, os.version = wp[1];
  if (webos) os.webos = true, os.version = webos[2];
  if (touchpad) os.touchpad = true;
  if (blackberry) os.blackberry = true, os.version = blackberry[2];
  if (bb10) os.bb10 = true, os.version = bb10[2];
  if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
  if (playbook) browser.playbook = true;
  if (kindle) os.kindle = true, os.version = kindle[1];
  if (silk) browser.silk = true, browser.version = silk[1];
  if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
  if (chrome) browser.chrome = true, browser.version = chrome[1];
  if (firefox) browser.firefox = true, browser.version = firefox[1];
  if (firefoxos) os.firefoxos = true, os.version = firefoxos[1];
  if (ie) browser.ie = true, browser.version = ie[1];

  if (safari && (osx || os.ios || win)) {
    browser.safari = true;
    if (!os.ios) browser.version = safari[1];
  }

  if (webview) browser.webview = true;
  os.tablet = !!(ipad || playbook || android && !ua.match(/Mobile/) || firefox && ua.match(/Tablet/) || ie && !ua.match(/Phone/) && ua.match(/Touch/));
  os.phone = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 || chrome && ua.match(/Android/) || chrome && ua.match(/CriOS\/([\d.]+)/) || firefox && ua.match(/Mobile/) || ie && ua.match(/Touch/)));
  return this;
}

var detectUtil = detect.call({}, navigator.userAgent, navigator.platform);

/**
 * 获取url的get参数
 * @param name {string} 要获取的参数名
 * @returns {string|null} 对应参数值
 */


var getQueryString = function getQueryString(name) {
  var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
  var r = window.location.search.substr(1).match(reg);
  if (r !== null) return decodeURIComponent(r[2]);
  return null;
};


var isFromApp = function isFromApp() {
  return !!navigator.userAgent.toLowerCase().match(/DFYJ/i);
}; //是否来自于微信


var isFromWeiXin = function isFromWeiXin() {
  return !!navigator.userAgent.toLowerCase().match(/MicroMessenger/i);
}; //是否是数组类型
/**
 * 判断是否为空
 * @param str {string} 需要判断的值
 * @returns {boolean}
 */


var isEmpty = function isEmpty(str) {
  return !(str != null && (!!str.length ? true : str.length > 0));
};


var getGuid = function getGuid() {
  function S4() {
    return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
  }

  return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
}; // 数组按照属性值降序排列

/**
 * Created by dfzq on 2017/7/31.
 */

/**
 * 末尾补.0
 * @param num 原始值
 * @param n   位数最大的值
 * @returns {*}
 */
var padZero = function padZero(num, n) {
  var len = num.split('.').length;

  while (len < n) {
    num = num + '.0';
    len++;
  }

  return num;
};
/**
 * 获取APP版本号
 * @param _
 * @returns {*}
 */


var getVersion = function getVersion(_) {
  var groups = navigator.userAgent.toLowerCase().match(/DFYJ\/([\d.]+)/i);

  if (!groups) {
    return undefined;
  } else {
    return groups[1];
  }
};
/**
 * arg1 > arg2, return 1; arg1 == arg2, return 0; arg1 < arg2, return -1
 * @param compareVersion
 * @returns {number}
 */


var _compareVersion = function _compareVersion(a, b) {
  // 补.0操作
  var _as = a.split('.');

  var _bs = b.split('.');

  var max = Math.max(_as.length, _bs.length);
  a = padZero(a, max);
  b = padZero(b, max);
  var as = a.split('.');
  var bs = b.split('.');
  if (a === b) return 0;

  for (var i = 0; i < as.length; i++) {
    var x = parseInt(as[i]);
    if (!bs[i]) return 1;
    var y = parseInt(bs[i]);
    if (x < y) return -1;
    if (x > y) return 1;
  }

  return -1;
};
/**
 * 比较APP版本，比compareVersion大则返回1，否则返回-1；相等返回0；
 * @param compareVersion
 * @returns {number}
 */


var compareVersion = function compareVersion(_compareVersion2) {
  // 获取当前版本号
  var currentVersion = getVersion();

  if (!currentVersion) {
    return 1;
  } else {
    return _compareVersion(currentVersion, _compareVersion2);
  }
};

/**
 * Created by dfzq on 2017/6/1.
 */

/**
 * 属性继承
 * @type {*}
 * @private
 */
var extendsUtil = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      // 源对象中是否存在对象键值
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Created by dfzq on 2017/7/28.
 */
var Authorize = /*#__PURE__*/function () {
  function Authorize() {
    _classCallCheck(this, Authorize);

    this.timestamp = new Date().valueOf();
  }

  _createClass(Authorize, [{
    key: "token",
    // 中台授权凭证（APP使用内存方式保存token，其他端则采用LocalStorage来存储） //
    set: function set(token) {
      this._token = token;
    },
    get: function get() {
      return this._token;
    } // 时间戳 起到混淆+盐值作用 //

  }], [{
    key: "isEmptyObject",

    /**
     * 判断是否是空对象
     * @param e
     * @returns {boolean}
     */
    value: function isEmptyObject(e) {
      var t;

      for (t in e) {
        return !1;
      }

      return !0;
    }
  }]);

  return Authorize;
}();

Authorize.BIZ_SYS_CREDIT = '6';
Authorize.BIZ_SYS_TRADE = '3';
Authorize.BIZ_SYS_OPTIONS = '18';
Authorize.BIZ_SYS_UNKNOWED = undefined;
Authorize.LOGIN_MET_MOBILE = '0';
Authorize.LOGIN_MET_SMS = '1';
Authorize.LOGIN_MET_FUNDACCOUNT = '2';

var WeixinAuthorize = /*#__PURE__*/function (_Authorize) {
  _inherits(WeixinAuthorize, _Authorize);

  var _super = _createSuper(WeixinAuthorize);

  function WeixinAuthorize() {
    _classCallCheck(this, WeixinAuthorize);

    return _super.apply(this, arguments);
  }

  _createClass(WeixinAuthorize, [{
    key: "openId",
    // 微信openid //
    set: function set(openId) {
      this._openId = openId;
    },
    get: function get() {
      return this._openId;
    } // 微信昵称 //

  }, {
    key: "nickName",
    set: function set(nickName) {
      this._nickName = nickName;
    },
    get: function get() {
      return this._nickName;
    }
  }]);

  return WeixinAuthorize;
}(Authorize);

/**
 * Created by dfzq on 2017/8/6.
 */
(function () {
  var url = function () {
    function _t() {
      return new RegExp(/(.*?)\.?([^\.]*?)\.?(com|net|org|biz|ws|in|me|co\.uk|co|org\.uk|ltd\.uk|plc\.uk|me\.uk|edu|mil|br\.com|cn\.com|eu\.com|hu\.com|no\.com|qc\.com|sa\.com|se\.com|se\.net|us\.com|uy\.com|ac|co\.ac|gv\.ac|or\.ac|ac\.ac|af|am|as|at|ac\.at|co\.at|gv\.at|or\.at|asn\.au|com\.au|edu\.au|org\.au|net\.au|id\.au|be|ac\.be|adm\.br|adv\.br|am\.br|arq\.br|art\.br|bio\.br|cng\.br|cnt\.br|com\.br|ecn\.br|eng\.br|esp\.br|etc\.br|eti\.br|fm\.br|fot\.br|fst\.br|g12\.br|gov\.br|ind\.br|inf\.br|jor\.br|lel\.br|med\.br|mil\.br|net\.br|nom\.br|ntr\.br|odo\.br|org\.br|ppg\.br|pro\.br|psc\.br|psi\.br|rec\.br|slg\.br|tmp\.br|tur\.br|tv\.br|vet\.br|zlg\.br|br|ab\.ca|bc\.ca|mb\.ca|nb\.ca|nf\.ca|ns\.ca|nt\.ca|on\.ca|pe\.ca|qc\.ca|sk\.ca|yk\.ca|ca|cc|ac\.cn|com\.cn|edu\.cn|gov\.cn|org\.cn|bj\.cn|sh\.cn|tj\.cn|cq\.cn|he\.cn|nm\.cn|ln\.cn|jl\.cn|hl\.cn|js\.cn|zj\.cn|ah\.cn|gd\.cn|gx\.cn|hi\.cn|sc\.cn|gz\.cn|yn\.cn|xz\.cn|sn\.cn|gs\.cn|qh\.cn|nx\.cn|xj\.cn|tw\.cn|hk\.cn|mo\.cn|cn|cx|cz|de|dk|fo|com\.ec|tm\.fr|com\.fr|asso\.fr|presse\.fr|fr|gf|gs|co\.il|net\.il|ac\.il|k12\.il|gov\.il|muni\.il|ac\.in|co\.in|org\.in|ernet\.in|gov\.in|net\.in|res\.in|is|it|ac\.jp|co\.jp|go\.jp|or\.jp|ne\.jp|ac\.kr|co\.kr|go\.kr|ne\.kr|nm\.kr|or\.kr|li|lt|lu|asso\.mc|tm\.mc|com\.mm|org\.mm|net\.mm|edu\.mm|gov\.mm|ms|nl|no|nu|pl|ro|org\.ro|store\.ro|tm\.ro|firm\.ro|www\.ro|arts\.ro|rec\.ro|info\.ro|nom\.ro|nt\.ro|se|si|com\.sg|org\.sg|net\.sg|gov\.sg|sk|st|tf|ac\.th|co\.th|go\.th|mi\.th|net\.th|or\.th|tm|to|com\.tr|edu\.tr|gov\.tr|k12\.tr|net\.tr|org\.tr|com\.tw|org\.tw|net\.tw|ac\.uk|uk\.com|uk\.net|gb\.com|gb\.net|vg|sh|kz|ch|info|ua|gov|name|pro|ie|hk|com\.hk|org\.hk|net\.hk|edu\.hk|us|tk|cd|by|ad|lv|eu\.lv|bz|es|jp|cl|ag|mobi|eu|co\.nz|org\.nz|net\.nz|maori\.nz|iwi\.nz|io|la|md|sc|sg|vc|tw|travel|my|se|tv|pt|com\.pt|edu\.pt|asia|fi|com\.ve|net\.ve|fi|org\.ve|web\.ve|info\.ve|co\.ve|tel|im|gr|ru|net\.ru|org\.ru|hr|com\.hr|ly|xyz)$/);
    }

    function _d(s) {
      return decodeURIComponent(s.replace(/\+/g, ' '));
    }

    function _i(arg, str) {
      var sptr = arg.charAt(0),
          split = str.split(sptr);

      if (sptr === arg) {
        return split;
      }

      arg = parseInt(arg.substring(1), 10);
      return split[arg < 0 ? split.length + arg : arg - 1];
    }

    function _f(arg, str) {
      var sptr = arg.charAt(0),
          split = str.split('&'),
          field = [],
          params = {},
          tmp = [],
          arg2 = arg.substring(1);

      for (var i = 0, ii = split.length; i < ii; i++) {
        field = split[i].match(/(.*?)=(.*)/); // TODO: regex should be able to handle this.

        if (!field) {
          field = [split[i], split[i], ''];
        }

        if (field[1].replace(/\s/g, '') !== '') {
          field[2] = _d(field[2] || ''); // If we have a match just return it right away.

          if (arg2 === field[1]) {
            return field[2];
          } // Check for array pattern.


          tmp = field[1].match(/(.*)\[([0-9]+)\]/);

          if (tmp) {
            params[tmp[1]] = params[tmp[1]] || [];
            params[tmp[1]][tmp[2]] = field[2];
          } else {
            params[field[1]] = field[2];
          }
        }
      }

      if (sptr === arg) {
        return params;
      }

      return params[arg2];
    }

    return function (arg, url) {
      var _l = {},
          tmp;

      if (arg === 'tld?') {
        return _t();
      }

      url = url || window.location.toString();

      if (!arg) {
        return url;
      }

      arg = arg.toString();

      if (tmp = url.match(/^mailto:([^\/].+)/)) {
        _l.protocol = 'mailto';
        _l.email = tmp[1];
      } else {
        // Ignore Hashbangs.
        if (tmp = url.match(/(.*?)\/#\!(.*)/)) {
          url = tmp[1] + tmp[2];
        } // Hash.


        if (tmp = url.match(/(.*?)#(.*)/)) {
          _l.hash = tmp[2];
          url = tmp[1];
        } // Return hash parts.


        if (_l.hash && arg.match(/^#/)) {
          return _f(arg, _l.hash);
        } // Query


        if (tmp = url.match(/(.*?)\?(.*)/)) {
          _l.query = tmp[2];
          url = tmp[1];
        } // Return query parts.


        if (_l.query && arg.match(/^\?/)) {
          return _f(arg, _l.query);
        } // Protocol.


        if (tmp = url.match(/(.*?)\:?\/\/(.*)/)) {
          _l.protocol = tmp[1].toLowerCase();
          url = tmp[2];
        } // Path.


        if (tmp = url.match(/(.*?)(\/.*)/)) {
          _l.path = tmp[2];
          url = tmp[1];
        } // Clean up path.


        _l.path = (_l.path || '').replace(/^([^\/])/, '/$1'); // Return path parts.

        if (arg.match(/^[\-0-9]+$/)) {
          arg = arg.replace(/^([^\/])/, '/$1');
        }

        if (arg.match(/^\//)) {
          return _i(arg, _l.path.substring(1));
        } // File.


        tmp = _i('/-1', _l.path.substring(1));

        if (tmp && (tmp = tmp.match(/(.*?)\.(.*)/))) {
          _l.file = tmp[0];
          _l.filename = tmp[1];
          _l.fileext = tmp[2];
        } // Port.


        if (tmp = url.match(/(.*)\:([0-9]+)$/)) {
          _l.port = tmp[2];
          url = tmp[1];
        } // Auth.


        if (tmp = url.match(/(.*?)@(.*)/)) {
          _l.auth = tmp[1];
          url = tmp[2];
        } // User and pass.


        if (_l.auth) {
          tmp = _l.auth.match(/(.*)\:(.*)/);
          _l.user = tmp ? tmp[1] : _l.auth;
          _l.pass = tmp ? tmp[2] : undefined;
        } // Hostname.


        _l.hostname = url.toLowerCase(); // Return hostname parts.

        if (arg.charAt(0) === '.') {
          return _i(arg, _l.hostname);
        } // Domain, tld and sub domain.


        if (_t()) {
          tmp = _l.hostname.match(_t());

          if (tmp) {
            _l.tld = tmp[3];
            _l.domain = tmp[2] ? tmp[2] + '.' + tmp[3] : undefined;
            _l.sub = tmp[1] || undefined;
          }
        } // Set port and protocol defaults if not set.


        _l.port = _l.port || (_l.protocol === 'https' ? '443' : '80');
        _l.protocol = _l.protocol || (_l.port === '443' ? 'https' : 'http');
      } // Return arg.


      if (arg in _l) {
        return _l[arg];
      } // Return everything.


      if (arg === '{}') {
        return _l;
      } // Default to undefined for no match.


      return undefined;
    };
  }();

  if (typeof window.define === 'function' && window.define.amd) {
    window.define('js-url', [], function () {
      return url;
    });
  } else {
    if (typeof window.jQuery !== 'undefined') {
      window.jQuery.extend({
        url: function url(arg, _url) {
          return window.url(arg, _url);
        }
      });
    }

    window.url = url;
  }
})();

/**
 * url解析工具包
 * Created by dfzq on 2017/8/6.
 */
/**
 * 获取绝对路径
 * @param url
 */

var getAbsoluteUrl = function getAbsoluteUrl(url) {
  var link = document.createElement('a');
  link.setAttribute('href', url);
  var absoluteUrl = link.href;
  link = null;
  return absoluteUrl;
};

//  * 根据相对path获取对应的根目录
//  * @param path 相对路径
//  */
// const pathMapToRootDirectory = (path) => {
//     // 待强制升级后规范这3个路径地址 TODO
//     if (path.indexOf('/account-') == 0){
//         return (configuration.accountBasePath === '/' ? '' : configuration.accountBasePath) + path
//     }
//     else if(path.indexOf('/financing-') == 0){
//         return (configuration.financingBasePath === '/' ? '' : configuration.financingBasePath) + path
//     }
//     else if(path.indexOf('/activity-') == 0){
//         return (configuration.activityBasePath === '/' ? '' : configuration.activityBasePath) + path
//     }
//     else if(path.indexOf('/ifeng-') == 0){
//         return (configuration.ifengBasePath === '/' ? '' : configuration.ifengBasePath) + path
//     }
//     else if(path.indexOf('/marketing-') == 0){
//         return (configuration.marketingBasePath === '/' ? '' : configuration.marketingBasePath) + path
//     }
//     else if(path.indexOf('/consult-') == 0){
//         return (configuration.consultBasePath === '/' ? '' : configuration.consultBasePath) + path
//     }
//     else if(path.indexOf('/check-') == 0){
//         return (configuration.checkBasePath === '/' ? '' : configuration.checkBasePath) + path
//     }
//     else{
//         console.warn('not find prefix of directory.')
//         return path
//     }
// }

/**
 * 为模块化部署的发布文件夹映射函数
 * 根据path的命名规范（目前采用分隔符来区分是本地访问还是服务端访问，本地访问通常只有3位，而服务端访问是4位）来添加服务端的根path
 * 发布文件夹命名定义：模块名-具体功能描述
 * 部署服务器的文件夹：html5-模块名-环境名
 *
 * @param path 相对路径
 */

var pathMapToRootDirectory = function pathMapToRootDirectory(path) {
  try {
    var moduleName;
    var pathNode = path.split('/'); // 20200413 linyiqing 这个变量用于区分v1和v2同时用了business需要区分

    var specialNode; // 为默认目录追加默认路径index.html

    if (pathNode.length === 2) {
      pathNode[2] = 'index.html';
    } // 3代表是本地访问模式，即通过webpack-server直接访问


    if (pathNode.length === 3) {
      // 取索引1中的《模块名-具体功能描述》，从而获取"模块名"
      moduleName = pathNode[1].split('-')[0];
      specialNode = pathNode[1].split('-')[1];
    } // 4代表是服务端访问模式，即通过浏览器直接访问远程URL
    else if (pathNode.length === 4) {
        moduleName = pathNode[2].split('-')[0];
        specialNode = pathNode[2].split('-')[1];
      } // 错误处理
      else {
          console.error('错误的目录命名规范!');
          return path;
        } // 服务发布文件夹名


    var directoryName = ''; // 环境名，当是mock,sit,dist的时候不需要添加环境

    var envName = '';

    if (configuration.appEnv === 'uat') {
      envName = "-".concat(configuration.appEnv);
    } // 20201120 linyiqing 增加通用的链接拼接逻辑 begin
    // 两个节点拼接的模块（人工维护）例如目录为fundia-open，跳转链接拼接后为html5-fundiaopen/fundia-open


    var concatModule = ['assetcenter', 'fundia']; // 只使用第一个节点的模块（人工维护）例如目录为fundia-open，跳转链接拼接后为html5-fundia/fundia-open

    var firstModule = []; // 只使用第二个节点的模块（人工维护）例如目录为fundia-open，跳转链接拼接后为html5-open/fundia-open

    var secondModule = []; // 3种新模式的处理

    if (concatModule.includes(moduleName)) {
      directoryName = "html5-".concat(moduleName).concat(specialNode).concat(envName);
    } else if (firstModule.includes(moduleName)) {
      directoryName = "html5-".concat(moduleName).concat(envName);
    } else if (secondModule.includes(moduleName)) {
      directoryName = "html5-".concat(specialNode).concat(envName);
    } // 20201120 linyiqing 增加通用的链接拼接逻辑 end 下方逻辑利旧不改造
    // 区分v2用到business模块时候特殊判断
    else if (moduleName === 'business' && specialNode !== 'accountcancellation' && specialNode !== 'accountescalation' && specialNode !== 'accountrelation' && specialNode !== 'index' && specialNode !== 'orientcash' && specialNode !== 'orienthui' && specialNode !== 'orientred' && specialNode !== 'pwdreset' && specialNode !== 'ttycancellation') {
        directoryName = "html5-".concat(specialNode).concat(envName);
      } else if (moduleName === 'business' && specialNode === 'index' || moduleName === 'fund' && specialNode === 'purchase') {
        directoryName = "html5-".concat(moduleName).concat(specialNode).concat(envName);
      } // TODO 目前financing、activity、business、check仍然部署在html5内，待拆分后细化
      else if (moduleName === 'financing' || moduleName === 'activity' || moduleName === 'business' || moduleName === 'check') {
          // // 服务端访问模式下才追加服务根Path，否则本地访问认为是同目录访问，不需要追加
          // if (pathNode.length === 4) {
          //     directoryName = 'html5'
          // }
          directoryName = "html5".concat(envName);
        } // 其他模块根据html5-模块名进行拼接
        else {
            directoryName = "html5-".concat(moduleName).concat(envName);
          } // 如果是本地模式，待跳转的模块与当前模块一致则不需要追加directoryName


    if (pathNode.length === 3) {
      var isSameModule = location.href.indexOf("/".concat(moduleName, "-")) != -1;

      if (isSameModule) {
        directoryName = '';
      }
    } // 替换索引0或1位


    var _index = pathNode.length === 3 ? 0 : 1;

    pathNode[_index] = directoryName;
    return pathNode.join('/');
  } catch (ex) {
    console.error("\u6620\u5C04\u76EE\u5F55\u65F6\u53D1\u751F\u9519\u8BEF\uFF1A".concat(ex));
    return path;
  }
};
/**
 * 序列化对象，生成key=value&key2=value2的形式
 * @param elms 需要序列化的object对象，必须是object类型
 * @returns {string}
 */


var serialize = function serialize(elms) {
  if (_typeof(elms) !== 'object') {
    return '';
  }

  var result = [];

  for (var name in elms) {
    result.push(encodeURIComponent(name) + '=' + encodeURIComponent(elms[name]));
  }

  return result.join('&');
};
/**
 * 将相对地址转化成映射的gateway绝对地址，并在该基础上可选的增加returnurl
 * @param originUrl 相对地址
 * @param returnurl 需要重定向的链接地址
 * @param queryStringParams 跳转地址对应的get参数，以object对象形式暴露
 * @returns {string}
 */


var createHref = (function (originUrl) {
  var returnurl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var queryStringParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  // 判断originUrl是否已经是一个绝对路径，如果是直接输出
  if (originUrl.indexOf('http') != -1 || originUrl.indexOf('https') != -1) {
    return originUrl;
  } // 通过相对路径解析成绝对路径+版本号


  var _originUrl;

  try {
    _originUrl = getAbsoluteUrl(originUrl);
  } catch (e) {
    throw new Error('relative path is error.');
  } // 根据当前绝对路径添加映射的根目录路径


  var protocol = window.url('protocol', _originUrl);
  var path = protocol + '://';
  var hostname = window.url('hostname', _originUrl);
  path += hostname; // http 80端口不处理 https 443端口不处理

  var port = window.url('port', _originUrl);

  if (port && port != '80' && port != '443') {
    path += ':' + port;
  } // 根据path的前缀来区分不同的根目录


  var _basePath = window.url('path', _originUrl);

  var basePath = pathMapToRootDirectory(_basePath);
  path += (basePath.charAt(0) === '/' ? basePath : "/".concat(basePath)) || '/';
  var search = window.url('query', _originUrl);

  if (search && search !== '?') {
    path += search.charAt(0) === '?' ? search : "?".concat(search);

    if (!isFromApp()) {
      // 加上版本号
      if (!search || search && search.indexOf('ver=') == -1) {
        path += '&ver=' + configuration.htmlVer;
      }
    } // 增加returnurl可选参数


    if (returnurl) {
      path += "&returnurl=".concat(encodeURIComponent(returnurl));
    } // 增加queryString可选参数


    if (queryStringParams) {
      var queryParams = serialize(queryStringParams);

      if (queryParams != '') {
        path += '&' + serialize(queryStringParams);
      }
    }
  } else {
    if (!isFromApp()) {
      // 加上版本号
      if (!search || search && search.indexOf('ver=') == -1) {
        var symbol = path.indexOf('?') != -1 ? '&' : '?';
        path += symbol + 'ver=' + configuration.htmlVer;
      }
    } // 增加returnurl可选参数


    if (returnurl) {
      var _symbol = path.indexOf('?') != -1 ? '&' : '?';

      path += _symbol + "returnurl=".concat(encodeURIComponent(returnurl));
    } // 增加queryString可选参数


    if (queryStringParams) {
      var _queryParams = serialize(queryStringParams);

      if (_queryParams != '') {
        var _symbol2 = path.indexOf('?') != -1 ? '&' : '?';

        path += _symbol2 + _queryParams;
      }
    }
  }

  var hash = window.url('hash', _originUrl);
  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : "#".concat(hash);
  return path;
});

/**
 * IF115000 - 当前时间(原IF060000)
 * */

var IF115000 = (function (onError) {
  return api("IF115000", {});
});

/**
 * V2版本中请不要使用该对象，由于oauth被修改为按需调用，因此在没有调用oauth的情况下该对象并没有数据
 */

var AppAuthorize = /*#__PURE__*/function (_WeixinAuthorize) {
  _inherits(AppAuthorize, _WeixinAuthorize);

  var _super = _createSuper(AppAuthorize);

  function AppAuthorize() {
    _classCallCheck(this, AppAuthorize);

    return _super.apply(this, arguments);
  }

  _createClass(AppAuthorize, [{
    key: "isLongLogin",

    /**
     * 是否保持着一级登录的会话态
     * true-已登录；false-未登录或已失效；
     */
    value: function isLongLogin() {
      try {
        if (typeof this.logon === "boolean") {
          return Promise.resolve(this.logon);
        } else {
          // const resp = getSystemTimeService()
          // if(resp.$baseApiHeader) {
          //   return resp.$baseApiHeader.state
          // }
          // else {
          //   return true;
          // }
          return new Promise(function (resolve, reject) {
            IF115000().then(function (resp) {
              return resolve(resp.header.state);
            }).otherwise(function (err) {
              return reject(err);
            });
          });
        }
      } catch (err) {
        return Promise.resolve(true);
      }
    } // 静态函数 //

    /**
     * 获取用户信息的本地存储
     */

  }, {
    key: "archive",
    // 公共函数 打开了app归档的操作权限，为了解决跳转OTC开通的问题 //

    /**
     * // 归档（APP不需要执行归档操作）
     * 归档（APP也需要执行归档操作）
     */
    value: function archive() {
      // // 使用浅复制恢复归档数据
      // let userDefault = AppAuthorize.userDefault()
      // if (!AppAuthorize.isEmptyObject(userDefault)) {
      //     let _userDefaultStringify = aes.decrypt(userDefault, AppAuthorize.AESKey).toString(utf8)
      //
      //     // 对象反序列
      //     let _lastUserDefault = JSON.parse(_userDefaultStringify)
      //
      //     extend(AppAuthorize.instance, _lastUserDefault)
      // }
      // 放开APP权限
      // if (!isFromApp()) {
      // 整包AES
      var _aes = aes.encrypt(JSON.stringify(this), AppAuthorize.AESKey).toString();

      store.set(AppAuthorize._ArchiveKey_, _aes); // }
    }
    /**
     * 接档
     */

  }, {
    key: "unarchive",
    value: function unarchive() {
      store.remove(AppAuthorize._ArchiveKey_);
    }
    /**
     * 是否需要执行数据恢复(登录页不需要恢复)
     */

  }, {
    key: "needStore",
    value: function needStore() {
      return !this._clientType && !this._storeFlag;
    }
  }, {
    key: "vtDeviceId",
    // APP虚拟设备号（非APP端该字段为空） //
    set: function set(vtDeviceId) {
      this._vtDeviceId = vtDeviceId;
    },
    get: function get() {
      return this._vtDeviceId;
    } // 登录方式 0-手机+登录密码 1-手机+短信验证码 2-资金账户 //

  }, {
    key: "loginMethod",
    set: function set(loginMethod) {
      this._loginMethod = loginMethod;
    },
    get: function get() {
      return this._loginMethod;
    } // 登录渠道 //

  }, {
    key: "loginChannel",
    set: function set(loginChannel) {
      this._loginChannel = loginChannel;
    },
    get: function get() {
      return this._loginChannel;
    } // 登录用户名 //

  }, {
    key: "loginUser",
    set: function set(loginUser) {
      this._loginUser = loginUser;
    },
    get: function get() {
      return this._loginUser;
    } // 客户类型 0-个人 1-机构 //

  }, {
    key: "clientType",
    set: function set(clientType) {
      this._clientType = clientType;
    },
    get: function get() {
      if (configuration.appEnv == 'mock') {
        return configuration.clientType;
      }

      return this._clientType;
    } // 当前所切换的资金账户（只有资金账户登录时适用该字段） //

  }, {
    key: "fundAccount",
    set: function set(fundAccount) {
      this._fundAccount = fundAccount;
    },
    get: function get() {
      if (configuration.appEnv == 'mock') {
        return '00127575';
      }

      return this._fundAccount;
    }
    /**
     * 是否个人用户
     * 返回类型: boolean
     */

  }, {
    key: "isPersonalUser",
    get: function get() {
      return this.clientType == "0";
    }
    /**
     * 是否机构用户
     * 返回类型: boolean
     */

  }, {
    key: "isOrganUser",
    get: function get() {
      return this.clientType == "1";
    } // 默认账户（由二级登录功能派生出来的定义）,数据结构设计如下:
    // [
    //  {
    //    key: fundAccount,     // 在原来的设计上简化了该字段的加密算法，去掉了md5算法
    //    value: {
    //       t: timestamp,
    //    },
    //  }
    // ]

  }, {
    key: "defaultAccount",
    set: function set(defaultAccount) {
      this._defaultAccount = this._defaultAccount || [];

      var defaultAccountObj = this._defaultAccount.find(function (n) {
        return n.key == defaultAccount;
      });

      if (defaultAccountObj) {
        // 获取该引用类型进行对应属性的赋值
        defaultAccountObj.value.t = new Date().valueOf();
      } else {
        var __defaultAccount = {
          key: defaultAccount,
          value: {
            t: new Date().valueOf()
          }
        };

        this._defaultAccount.push(__defaultAccount);
      }
    } // 根据最新的timestamp返回最近的账户作为默认账户
    ,
    get: function get() {
      try {
        this._defaultAccount = this._defaultAccount || [];

        if (this._defaultAccount.length <= 0) {
          return null;
        } else {
          this._defaultAccount = this._defaultAccount.sort(function (a, b) {
            return b.value.t - a.value.t;
          });
          return this._defaultAccount[0];
        }
      } catch (e) {
        return null;
      }
    } // 系统编号（只有资金账户登录时使用该字段） //

  }, {
    key: "bizSysId",
    set: function set(bizSysId) {
      this._bizSysId = bizSysId;
    },
    get: function get() {
      if (!isFromApp()) {
        if (configuration.appEnv == 'mock') {
          return configuration.bizSysId;
        } else if (this.defaultAccount.key.length == 8) {
          if (this.defaultAccount.key.indexOf('988') == 0) {
            return Authorize.BIZ_SYS_CREDIT;
          } else {
            return Authorize.BIZ_SYS_TRADE;
          }
        } else if (this.defaultAccount.key.length == 10) {
          return Authorize.BIZ_SYS_OPTIONS;
        } else {
          return Authorize.BIZ_SYS_UNKNOWED;
        }
      }

      return this._bizSysId;
    }
    /**
     * 是否交易资金账号
     * 返回类型: boolean
     */

  }, {
    key: "isTradeAccount",
    get: function get() {
      return this.bizSysId == Authorize.BIZ_SYS_TRADE;
    }
    /**
     * 是否信用资金账号
     * 返回类型: boolean
     */

  }, {
    key: "isCreditAccount",
    get: function get() {
      return this.bizSysId == Authorize.BIZ_SYS_CREDIT;
    }
    /**
     * 是否期权资金账号
     * 返回类型: boolean
     */

  }, {
    key: "isOptionsAccount",
    get: function get() {
      return this.bizSysId == Authorize.BIZ_SYS_OPTIONS;
    } // 客户名称，可能为空 //

  }, {
    key: "clientName",
    set: function set(clientName) {
      this._clientName = clientName;
    },
    get: function get() {
      return this._clientName;
    } // 是否恢复标识 //

  }, {
    key: "storeFlag",
    set: function set(storeFlag) {
      this._storeFlag = storeFlag;
    },
    get: function get() {
      return this._storeFlag;
    } // refreshToken 方案前的 auth header，4.12.0开始由 newAuthSign 替代 //

  }, {
    key: "authSign",
    set: function set(authSign) {
      this._authSign = authSign;
    },
    get: function get() {
      return this._authSign;
    }
  }, {
    key: "refreshToken",
    set: function set(refreshToken) {
      this._refreshToken = refreshToken;
    },
    get: function get() {
      return isEmpty(this._refreshToken) ? "" : this._refreshToken;
    }
    /**
     * 登录状态
     * true-已登录；false-未登录
     */

  }, {
    key: "logon",
    set: function set(logon) {
      this._logon = logon;
    },
    get: function get() {
      return this._logon;
    } // 生成auth header //
    // <4.12.0: 返回 this._authSign //
    // >=4.12.0: 返回 {loginUser}:4:{refreshToken} //

  }, {
    key: "newAuthSign",
    get: function get() {
      // <4.12.0
      if (isEmpty(this.refreshToken)) {
        return this.authSign;
      } // >=4.12.0
      else {
          return "".concat(this.loginUser, ":4:").concat(this.refreshToken);
        }
    }
  }], [{
    key: "getInstance",
    // userDefault用户基础信息本地化存储的Key值
    // AES算法所使用到的密钥

    /**
     * 单例模式
     * @returns {AppAuthorize}
     */
    value: function getInstance() {
      if (!AppAuthorize.instance) {
        AppAuthorize.instance = new AppAuthorize();
        console.log(Authorize.isEmptyObject);

        if (!Authorize.isEmptyObject(this.userDefault())) {
          /** 接档操作，用于前一次的本地存储数据恢复，只针对非APP端做次操作 **/
          if (!isFromApp()) {
            try {
              // AES解密
              var _userDefaultStringify = aes.decrypt(this.userDefault(), AppAuthorize.AESKey).toString(utf8); // 对象反序列


              var _lastUserDefault = JSON.parse(_userDefaultStringify); // 浅复制


              extendsUtil(AppAuthorize.instance, _lastUserDefault);
            } catch (e) {
              // 容错处理，万一出现store中数据反序列化错误则直接要求重复登录（可能被篡改）
              this.removeUserDefault();
              location.href = createHref('../account-login2/index.html', location.href);
            }
          }
        }
      }

      return AppAuthorize.instance;
    }
  }, {
    key: "userDefault",
    value: function userDefault() {
      return !store.get(AppAuthorize._ArchiveKey_) ? {} : store.get(AppAuthorize._ArchiveKey_);
    }
    /**
     * 清除用户信息的本地存储
     */

  }, {
    key: "removeUserDefault",
    value: function removeUserDefault() {
      store.remove(AppAuthorize._ArchiveKey_);
    }
  }]);

  return AppAuthorize;
}(WeixinAuthorize);

AppAuthorize._ArchiveKey_ = '__DF_u__';
AppAuthorize.AESKey = 'DF-kf6';
var AppAuthorize$1 = AppAuthorize.getInstance();

/*
* Fingerprintjs2sync 1.5.2 - Synchronous version of fingerprintjs2
* https://github.com/valnub/fingerprintjs2sync
* Copyright (c) 2015 Valentin Vasilyev (valentin.vasilyev@outlook.com)
* Fork by Timo Ernst
* Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL VALENTIN VASILYEV BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var Fingerprint2 = function Fingerprint2(options) {
  if (!(this instanceof Fingerprint2)) {
    return new Fingerprint2(options);
  }

  var defaultOptions = {
    swfContainerId: "fingerprintjs2",
    swfPath: "flash/compiled/FontList.swf",
    detectScreenOrientation: true,
    sortPluginsFor: [/palemoon/i],
    userDefinedFonts: []
  };
  this.options = this.extend(options, defaultOptions);
  this.nativeForEach = Array.prototype.forEach;
  this.nativeMap = Array.prototype.map;
};

Fingerprint2.prototype = {
  extend: function extend(source, target) {
    if (source == null) {
      return target;
    }

    for (var k in source) {
      if (source[k] != null && target[k] !== source[k]) {
        target[k] = source[k];
      }
    }

    return target;
  },
  getSync: function getSync() {
    var keys = [];
    keys = this.userAgentKey(keys);
    keys = this.languageKey(keys);
    keys = this.colorDepthKey(keys);
    keys = this.pixelRatioKey(keys);
    keys = this.hardwareConcurrencyKey(keys);
    keys = this.screenResolutionKey(keys);
    keys = this.availableScreenResolutionKey(keys);
    keys = this.timezoneOffsetKey(keys);
    keys = this.sessionStorageKey(keys);
    keys = this.localStorageKey(keys);
    keys = this.indexedDbKey(keys);
    keys = this.addBehaviorKey(keys);
    keys = this.openDatabaseKey(keys);
    keys = this.cpuClassKey(keys);
    keys = this.platformKey(keys);
    keys = this.doNotTrackKey(keys);
    keys = this.pluginsKey(keys);
    keys = this.canvasKey(keys);
    keys = this.webglKey(keys);
    keys = this.adBlockKey(keys);
    keys = this.hasLiedLanguagesKey(keys);
    keys = this.hasLiedResolutionKey(keys);
    keys = this.hasLiedOsKey(keys);
    keys = this.hasLiedBrowserKey(keys);
    keys = this.touchSupportKey(keys);
    keys = this.customEntropyFunction(keys);
    var that = this;
    var newKeys = this.fontsKey(keys);
    var values = [];
    that.each(newKeys, function (pair) {
      var value = pair.value;

      if (typeof pair.value.join !== "undefined") {
        value = pair.value.join(";");
      }

      values.push(value);
    });
    var murmur = that.x64hash128(values.join("~~~"), 31);
    return {
      fprint: murmur,
      newKeys: newKeys
    };
  },
  customEntropyFunction: function customEntropyFunction(keys) {
    if (typeof this.options.customFunction === "function") {
      keys.push({
        key: "custom",
        value: this.options.customFunction()
      });
    }

    return keys;
  },
  userAgentKey: function userAgentKey(keys) {
    if (!this.options.excludeUserAgent) {
      keys.push({
        key: "user_agent",
        value: this.getUserAgent()
      });
    }

    return keys;
  },
  // for tests
  getUserAgent: function getUserAgent() {
    return navigator.userAgent;
  },
  languageKey: function languageKey(keys) {
    if (!this.options.excludeLanguage) {
      // IE 9,10 on Windows 10 does not have the `navigator.language` property any longer
      keys.push({
        key: "language",
        value: navigator.language || navigator.userLanguage || navigator.browserLanguage || navigator.systemLanguage || ""
      });
    }

    return keys;
  },
  colorDepthKey: function colorDepthKey(keys) {
    if (!this.options.excludeColorDepth) {
      keys.push({
        key: "color_depth",
        value: screen.colorDepth || -1
      });
    }

    return keys;
  },
  pixelRatioKey: function pixelRatioKey(keys) {
    if (!this.options.excludePixelRatio) {
      keys.push({
        key: "pixel_ratio",
        value: this.getPixelRatio()
      });
    }

    return keys;
  },
  getPixelRatio: function getPixelRatio() {
    return window.devicePixelRatio || "";
  },
  screenResolutionKey: function screenResolutionKey(keys) {
    if (!this.options.excludeScreenResolution) {
      return this.getScreenResolution(keys);
    }

    return keys;
  },
  getScreenResolution: function getScreenResolution(keys) {
    var resolution;

    if (this.options.detectScreenOrientation) {
      resolution = screen.height > screen.width ? [screen.height, screen.width] : [screen.width, screen.height];
    } else {
      resolution = [screen.width, screen.height];
    }

    if (typeof resolution !== "undefined") {
      // headless browsers
      keys.push({
        key: "resolution",
        value: resolution
      });
    }

    return keys;
  },
  availableScreenResolutionKey: function availableScreenResolutionKey(keys) {
    if (!this.options.excludeAvailableScreenResolution) {
      return this.getAvailableScreenResolution(keys);
    }

    return keys;
  },
  getAvailableScreenResolution: function getAvailableScreenResolution(keys) {
    var available;

    if (screen.availWidth && screen.availHeight) {
      if (this.options.detectScreenOrientation) {
        available = screen.availHeight > screen.availWidth ? [screen.availHeight, screen.availWidth] : [screen.availWidth, screen.availHeight];
      } else {
        available = [screen.availHeight, screen.availWidth];
      }
    }

    if (typeof available !== "undefined") {
      // headless browsers
      keys.push({
        key: "available_resolution",
        value: available
      });
    }

    return keys;
  },
  timezoneOffsetKey: function timezoneOffsetKey(keys) {
    if (!this.options.excludeTimezoneOffset) {
      keys.push({
        key: "timezone_offset",
        value: new Date().getTimezoneOffset()
      });
    }

    return keys;
  },
  sessionStorageKey: function sessionStorageKey(keys) {
    if (!this.options.excludeSessionStorage && this.hasSessionStorage()) {
      keys.push({
        key: "session_storage",
        value: 1
      });
    }

    return keys;
  },
  localStorageKey: function localStorageKey(keys) {
    if (!this.options.excludeSessionStorage && this.hasLocalStorage()) {
      keys.push({
        key: "local_storage",
        value: 1
      });
    }

    return keys;
  },
  indexedDbKey: function indexedDbKey(keys) {
    if (!this.options.excludeIndexedDB && this.hasIndexedDB()) {
      keys.push({
        key: "indexed_db",
        value: 1
      });
    }

    return keys;
  },
  addBehaviorKey: function addBehaviorKey(keys) {
    //body might not be defined at this point or removed programmatically
    if (document.body && !this.options.excludeAddBehavior && document.body.addBehavior) {
      keys.push({
        key: "add_behavior",
        value: 1
      });
    }

    return keys;
  },
  openDatabaseKey: function openDatabaseKey(keys) {
    if (!this.options.excludeOpenDatabase && window.openDatabase) {
      keys.push({
        key: "open_database",
        value: 1
      });
    }

    return keys;
  },
  cpuClassKey: function cpuClassKey(keys) {
    if (!this.options.excludeCpuClass) {
      keys.push({
        key: "cpu_class",
        value: this.getNavigatorCpuClass()
      });
    }

    return keys;
  },
  platformKey: function platformKey(keys) {
    if (!this.options.excludePlatform) {
      keys.push({
        key: "navigator_platform",
        value: this.getNavigatorPlatform()
      });
    }

    return keys;
  },
  doNotTrackKey: function doNotTrackKey(keys) {
    if (!this.options.excludeDoNotTrack) {
      keys.push({
        key: "do_not_track",
        value: this.getDoNotTrack()
      });
    }

    return keys;
  },
  canvasKey: function canvasKey(keys) {
    if (!this.options.excludeCanvas && this.isCanvasSupported()) {
      keys.push({
        key: "canvas",
        value: this.getCanvasFp()
      });
    }

    return keys;
  },
  webglKey: function webglKey(keys) {
    if (this.options.excludeWebGL) {
      return keys;
    }

    if (!this.isWebGlSupported()) {
      return keys;
    }

    keys.push({
      key: "webgl",
      value: this.getWebglFp()
    });
    return keys;
  },
  adBlockKey: function adBlockKey(keys) {
    if (!this.options.excludeAdBlock) {
      keys.push({
        key: "adblock",
        value: this.getAdBlock()
      });
    }

    return keys;
  },
  hasLiedLanguagesKey: function hasLiedLanguagesKey(keys) {
    if (!this.options.excludeHasLiedLanguages) {
      keys.push({
        key: "has_lied_languages",
        value: this.getHasLiedLanguages()
      });
    }

    return keys;
  },
  hasLiedResolutionKey: function hasLiedResolutionKey(keys) {
    if (!this.options.excludeHasLiedResolution) {
      keys.push({
        key: "has_lied_resolution",
        value: this.getHasLiedResolution()
      });
    }

    return keys;
  },
  hasLiedOsKey: function hasLiedOsKey(keys) {
    if (!this.options.excludeHasLiedOs) {
      keys.push({
        key: "has_lied_os",
        value: this.getHasLiedOs()
      });
    }

    return keys;
  },
  hasLiedBrowserKey: function hasLiedBrowserKey(keys) {
    if (!this.options.excludeHasLiedBrowser) {
      keys.push({
        key: "has_lied_browser",
        value: this.getHasLiedBrowser()
      });
    }

    return keys;
  },
  // kudos to http://www.lalit.org/lab/javascript-css-font-detect/
  fontsKey: function fontsKey(keys) {
    var that = this; // a font will be compared against all the three default fonts.
    // and if it doesn't match all 3 then that font is not available.

    var baseFonts = ["monospace", "sans-serif", "serif"];
    var fontList = ["Andale Mono", "Arial", "Arial Black", "Arial Hebrew", "Arial MT", "Arial Narrow", "Arial Rounded MT Bold", "Arial Unicode MS", "Bitstream Vera Sans Mono", "Book Antiqua", "Bookman Old Style", "Calibri", "Cambria", "Cambria Math", "Century", "Century Gothic", "Century Schoolbook", "Comic Sans", "Comic Sans MS", "Consolas", "Courier", "Courier New", "Garamond", "Geneva", "Georgia", "Helvetica", "Helvetica Neue", "Impact", "Lucida Bright", "Lucida Calligraphy", "Lucida Console", "Lucida Fax", "LUCIDA GRANDE", "Lucida Handwriting", "Lucida Sans", "Lucida Sans Typewriter", "Lucida Sans Unicode", "Microsoft Sans Serif", "Monaco", "Monotype Corsiva", "MS Gothic", "MS Outlook", "MS PGothic", "MS Reference Sans Serif", "MS Sans Serif", "MS Serif", "MYRIAD", "MYRIAD PRO", "Palatino", "Palatino Linotype", "Segoe Print", "Segoe Script", "Segoe UI", "Segoe UI Light", "Segoe UI Semibold", "Segoe UI Symbol", "Tahoma", "Times", "Times New Roman", "Times New Roman PS", "Trebuchet MS", "Verdana", "Wingdings", "Wingdings 2", "Wingdings 3"];
    var extendedFontList = ["Abadi MT Condensed Light", "Academy Engraved LET", "ADOBE CASLON PRO", "Adobe Garamond", "ADOBE GARAMOND PRO", "Agency FB", "Aharoni", "Albertus Extra Bold", "Albertus Medium", "Algerian", "Amazone BT", "American Typewriter", "American Typewriter Condensed", "AmerType Md BT", "Andalus", "Angsana New", "AngsanaUPC", "Antique Olive", "Aparajita", "Apple Chancery", "Apple Color Emoji", "Apple SD Gothic Neo", "Arabic Typesetting", "ARCHER", "ARNO PRO", "Arrus BT", "Aurora Cn BT", "AvantGarde Bk BT", "AvantGarde Md BT", "AVENIR", "Ayuthaya", "Bandy", "Bangla Sangam MN", "Bank Gothic", "BankGothic Md BT", "Baskerville", "Baskerville Old Face", "Batang", "BatangChe", "Bauer Bodoni", "Bauhaus 93", "Bazooka", "Bell MT", "Bembo", "Benguiat Bk BT", "Berlin Sans FB", "Berlin Sans FB Demi", "Bernard MT Condensed", "BernhardFashion BT", "BernhardMod BT", "Big Caslon", "BinnerD", "Blackadder ITC", "BlairMdITC TT", "Bodoni 72", "Bodoni 72 Oldstyle", "Bodoni 72 Smallcaps", "Bodoni MT", "Bodoni MT Black", "Bodoni MT Condensed", "Bodoni MT Poster Compressed", "Bookshelf Symbol 7", "Boulder", "Bradley Hand", "Bradley Hand ITC", "Bremen Bd BT", "Britannic Bold", "Broadway", "Browallia New", "BrowalliaUPC", "Brush Script MT", "Californian FB", "Calisto MT", "Calligrapher", "Candara", "CaslonOpnface BT", "Castellar", "Centaur", "Cezanne", "CG Omega", "CG Times", "Chalkboard", "Chalkboard SE", "Chalkduster", "Charlesworth", "Charter Bd BT", "Charter BT", "Chaucer", "ChelthmITC Bk BT", "Chiller", "Clarendon", "Clarendon Condensed", "CloisterBlack BT", "Cochin", "Colonna MT", "Constantia", "Cooper Black", "Copperplate", "Copperplate Gothic", "Copperplate Gothic Bold", "Copperplate Gothic Light", "CopperplGoth Bd BT", "Corbel", "Cordia New", "CordiaUPC", "Cornerstone", "Coronet", "Cuckoo", "Curlz MT", "DaunPenh", "Dauphin", "David", "DB LCD Temp", "DELICIOUS", "Denmark", "DFKai-SB", "Didot", "DilleniaUPC", "DIN", "DokChampa", "Dotum", "DotumChe", "Ebrima", "Edwardian Script ITC", "Elephant", "English 111 Vivace BT", "Engravers MT", "EngraversGothic BT", "Eras Bold ITC", "Eras Demi ITC", "Eras Light ITC", "Eras Medium ITC", "EucrosiaUPC", "Euphemia", "Euphemia UCAS", "EUROSTILE", "Exotc350 Bd BT", "FangSong", "Felix Titling", "Fixedsys", "FONTIN", "Footlight MT Light", "Forte", "FrankRuehl", "Fransiscan", "Freefrm721 Blk BT", "FreesiaUPC", "Freestyle Script", "French Script MT", "FrnkGothITC Bk BT", "Fruitger", "FRUTIGER", "Futura", "Futura Bk BT", "Futura Lt BT", "Futura Md BT", "Futura ZBlk BT", "FuturaBlack BT", "Gabriola", "Galliard BT", "Gautami", "Geeza Pro", "Geometr231 BT", "Geometr231 Hv BT", "Geometr231 Lt BT", "GeoSlab 703 Lt BT", "GeoSlab 703 XBd BT", "Gigi", "Gill Sans", "Gill Sans MT", "Gill Sans MT Condensed", "Gill Sans MT Ext Condensed Bold", "Gill Sans Ultra Bold", "Gill Sans Ultra Bold Condensed", "Gisha", "Gloucester MT Extra Condensed", "GOTHAM", "GOTHAM BOLD", "Goudy Old Style", "Goudy Stout", "GoudyHandtooled BT", "GoudyOLSt BT", "Gujarati Sangam MN", "Gulim", "GulimChe", "Gungsuh", "GungsuhChe", "Gurmukhi MN", "Haettenschweiler", "Harlow Solid Italic", "Harrington", "Heather", "Heiti SC", "Heiti TC", "HELV", "Herald", "High Tower Text", "Hiragino Kaku Gothic ProN", "Hiragino Mincho ProN", "Hoefler Text", "Humanst 521 Cn BT", "Humanst521 BT", "Humanst521 Lt BT", "Imprint MT Shadow", "Incised901 Bd BT", "Incised901 BT", "Incised901 Lt BT", "INCONSOLATA", "Informal Roman", "Informal011 BT", "INTERSTATE", "IrisUPC", "Iskoola Pota", "JasmineUPC", "Jazz LET", "Jenson", "Jester", "Jokerman", "Juice ITC", "Kabel Bk BT", "Kabel Ult BT", "Kailasa", "KaiTi", "Kalinga", "Kannada Sangam MN", "Kartika", "Kaufmann Bd BT", "Kaufmann BT", "Khmer UI", "KodchiangUPC", "Kokila", "Korinna BT", "Kristen ITC", "Krungthep", "Kunstler Script", "Lao UI", "Latha", "Leelawadee", "Letter Gothic", "Levenim MT", "LilyUPC", "Lithograph", "Lithograph Light", "Long Island", "Lydian BT", "Magneto", "Maiandra GD", "Malayalam Sangam MN", "Malgun Gothic", "Mangal", "Marigold", "Marion", "Marker Felt", "Market", "Marlett", "Matisse ITC", "Matura MT Script Capitals", "Meiryo", "Meiryo UI", "Microsoft Himalaya", "Microsoft JhengHei", "Microsoft New Tai Lue", "Microsoft PhagsPa", "Microsoft Tai Le", "Microsoft Uighur", "Microsoft YaHei", "Microsoft Yi Baiti", "MingLiU", "MingLiU_HKSCS", "MingLiU_HKSCS-ExtB", "MingLiU-ExtB", "Minion", "Minion Pro", "Miriam", "Miriam Fixed", "Mistral", "Modern", "Modern No. 20", "Mona Lisa Solid ITC TT", "Mongolian Baiti", "MONO", "MoolBoran", "Mrs Eaves", "MS LineDraw", "MS Mincho", "MS PMincho", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MUSEO", "MV Boli", "Nadeem", "Narkisim", "NEVIS", "News Gothic", "News GothicMT", "NewsGoth BT", "Niagara Engraved", "Niagara Solid", "Noteworthy", "NSimSun", "Nyala", "OCR A Extended", "Old Century", "Old English Text MT", "Onyx", "Onyx BT", "OPTIMA", "Oriya Sangam MN", "OSAKA", "OzHandicraft BT", "Palace Script MT", "Papyrus", "Parchment", "Party LET", "Pegasus", "Perpetua", "Perpetua Titling MT", "PetitaBold", "Pickwick", "Plantagenet Cherokee", "Playbill", "PMingLiU", "PMingLiU-ExtB", "Poor Richard", "Poster", "PosterBodoni BT", "PRINCETOWN LET", "Pristina", "PTBarnum BT", "Pythagoras", "Raavi", "Rage Italic", "Ravie", "Ribbon131 Bd BT", "Rockwell", "Rockwell Condensed", "Rockwell Extra Bold", "Rod", "Roman", "Sakkal Majalla", "Santa Fe LET", "Savoye LET", "Sceptre", "Script", "Script MT Bold", "SCRIPTINA", "Serifa", "Serifa BT", "Serifa Th BT", "ShelleyVolante BT", "Sherwood", "Shonar Bangla", "Showcard Gothic", "Shruti", "Signboard", "SILKSCREEN", "SimHei", "Simplified Arabic", "Simplified Arabic Fixed", "SimSun", "SimSun-ExtB", "Sinhala Sangam MN", "Sketch Rockwell", "Skia", "Small Fonts", "Snap ITC", "Snell Roundhand", "Socket", "Souvenir Lt BT", "Staccato222 BT", "Steamer", "Stencil", "Storybook", "Styllo", "Subway", "Swis721 BlkEx BT", "Swiss911 XCm BT", "Sylfaen", "Synchro LET", "System", "Tamil Sangam MN", "Technical", "Teletype", "Telugu Sangam MN", "Tempus Sans ITC", "Terminal", "Thonburi", "Traditional Arabic", "Trajan", "TRAJAN PRO", "Tristan", "Tubular", "Tunga", "Tw Cen MT", "Tw Cen MT Condensed", "Tw Cen MT Condensed Extra Bold", "TypoUpright BT", "Unicorn", "Univers", "Univers CE 55 Medium", "Univers Condensed", "Utsaah", "Vagabond", "Vani", "Vijaya", "Viner Hand ITC", "VisualUI", "Vivaldi", "Vladimir Script", "Vrinda", "Westminster", "WHITNEY", "Wide Latin", "ZapfEllipt BT", "ZapfHumnst BT", "ZapfHumnst Dm BT", "Zapfino", "Zurich BlkEx BT", "Zurich Ex BT", "ZWAdobeF"];

    if (that.options.extendedJsFonts) {
      fontList = fontList.concat(extendedFontList);
    }

    fontList = fontList.concat(that.options.userDefinedFonts); //we use m or w because these two characters take up the maximum width.
    // And we use a LLi so that the same matching fonts can get separated

    var testString = "mmmmmmmmmmlli"; //we test using 72px font size, we may use any size. I guess larger the better.

    var testSize = "72px";
    var h = document.getElementsByTagName("body")[0]; // div to load spans for the base fonts

    var baseFontsDiv = document.createElement("div"); // div to load spans for the fonts to detect

    var fontsDiv = document.createElement("div");
    var defaultWidth = {};
    var defaultHeight = {}; // creates a span where the fonts will be loaded

    var createSpan = function createSpan() {
      var s = document.createElement("span");
      /*
       * We need this css as in some weird browser this
       * span elements shows up for a microSec which creates a
       * bad user experience
       */

      s.style.position = "absolute";
      s.style.left = "-9999px";
      s.style.fontSize = testSize;
      s.style.lineHeight = "normal";
      s.innerHTML = testString;
      return s;
    }; // creates a span and load the font to detect and a base font for fallback


    var createSpanWithFonts = function createSpanWithFonts(fontToDetect, baseFont) {
      var s = createSpan();
      s.style.fontFamily = "'" + fontToDetect + "'," + baseFont;
      return s;
    }; // creates spans for the base fonts and adds them to baseFontsDiv


    var initializeBaseFontsSpans = function initializeBaseFontsSpans() {
      var spans = [];

      for (var index = 0, length = baseFonts.length; index < length; index++) {
        var s = createSpan();
        s.style.fontFamily = baseFonts[index];
        baseFontsDiv.appendChild(s);
        spans.push(s);
      }

      return spans;
    }; // creates spans for the fonts to detect and adds them to fontsDiv


    var initializeFontsSpans = function initializeFontsSpans() {
      var spans = {};

      for (var i = 0, l = fontList.length; i < l; i++) {
        var fontSpans = [];

        for (var j = 0, numDefaultFonts = baseFonts.length; j < numDefaultFonts; j++) {
          var s = createSpanWithFonts(fontList[i], baseFonts[j]);
          fontsDiv.appendChild(s);
          fontSpans.push(s);
        }

        spans[fontList[i]] = fontSpans; // Stores {fontName : [spans for that font]}
      }

      return spans;
    }; // checks if a font is available


    var isFontAvailable = function isFontAvailable(fontSpans) {
      var detected = false;

      for (var i = 0; i < baseFonts.length; i++) {
        detected = fontSpans[i].offsetWidth !== defaultWidth[baseFonts[i]] || fontSpans[i].offsetHeight !== defaultHeight[baseFonts[i]];

        if (detected) {
          return detected;
        }
      }

      return detected;
    }; // create spans for base fonts


    var baseFontsSpans = initializeBaseFontsSpans(); // add the spans to the DOM

    h.appendChild(baseFontsDiv); // get the default width for the three base fonts

    for (var index = 0, length = baseFonts.length; index < length; index++) {
      defaultWidth[baseFonts[index]] = baseFontsSpans[index].offsetWidth; // width for the default font

      defaultHeight[baseFonts[index]] = baseFontsSpans[index].offsetHeight; // height for the default font
    } // create spans for fonts to detect


    var fontsSpans = initializeFontsSpans(); // add all the spans to the DOM

    h.appendChild(fontsDiv); // check available fonts

    var available = [];

    for (var i = 0, l = fontList.length; i < l; i++) {
      if (isFontAvailable(fontsSpans[fontList[i]])) {
        available.push(fontList[i]);
      }
    } // remove spans from DOM


    h.removeChild(fontsDiv);
    h.removeChild(baseFontsDiv);
    keys.push({
      key: "js_fonts",
      value: available
    });
    return keys;
  },
  pluginsKey: function pluginsKey(keys) {
    if (!this.options.excludePlugins) {
      if (this.isIE()) {
        if (!this.options.excludeIEPlugins) {
          keys.push({
            key: "ie_plugins",
            value: this.getIEPlugins()
          });
        }
      } else {
        keys.push({
          key: "regular_plugins",
          value: this.getRegularPlugins()
        });
      }
    }

    return keys;
  },
  getRegularPlugins: function getRegularPlugins() {
    var plugins = [];

    for (var i = 0, l = navigator.plugins.length; i < l; i++) {
      plugins.push(navigator.plugins[i]);
    } // sorting plugins only for those user agents, that we know randomize the plugins
    // every time we try to enumerate them


    if (this.pluginsShouldBeSorted()) {
      plugins = plugins.sort(function (a, b) {
        if (a.name > b.name) {
          return 1;
        }

        if (a.name < b.name) {
          return -1;
        }

        return 0;
      });
    }

    return this.map(plugins, function (p) {
      var mimeTypes = this.map(p, function (mt) {
        return [mt.type, mt.suffixes].join("~");
      }).join(",");
      return [p.name, p.description, mimeTypes].join("::");
    }, this);
  },
  getIEPlugins: function getIEPlugins() {
    var result = [];

    if (Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(window, "ActiveXObject") || "ActiveXObject" in window) {
      var names = ["AcroPDF.PDF", // Adobe PDF reader 7+
      "Adodb.Stream", "AgControl.AgControl", // Silverlight
      "DevalVRXCtrl.DevalVRXCtrl.1", "MacromediaFlashPaper.MacromediaFlashPaper", "Msxml2.DOMDocument", "Msxml2.XMLHTTP", "PDF.PdfCtrl", // Adobe PDF reader 6 and earlier, brrr
      "QuickTime.QuickTime", // QuickTime
      "QuickTimeCheckObject.QuickTimeCheck.1", "RealPlayer", "RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)", "RealVideo.RealVideo(tm) ActiveX Control (32-bit)", "Scripting.Dictionary", "SWCtl.SWCtl", // ShockWave player
      "Shell.UIHelper", "ShockwaveFlash.ShockwaveFlash", //flash plugin
      "Skype.Detection", "TDCCtl.TDCCtl", "WMPlayer.OCX", // Windows media player
      "rmocx.RealPlayer G2 Control", "rmocx.RealPlayer G2 Control.1"]; // starting to detect plugins in IE

      result = this.map(names, function (name) {
        try {
          new ActiveXObject(name); // eslint-disable-no-new

          return name;
        } catch (e) {
          return null;
        }
      });
    }

    if (navigator.plugins) {
      result = result.concat(this.getRegularPlugins());
    }

    return result;
  },
  pluginsShouldBeSorted: function pluginsShouldBeSorted() {
    var should = false;

    for (var i = 0, l = this.options.sortPluginsFor.length; i < l; i++) {
      var re = this.options.sortPluginsFor[i];

      if (navigator.userAgent.match(re)) {
        should = true;
        break;
      }
    }

    return should;
  },
  touchSupportKey: function touchSupportKey(keys) {
    if (!this.options.excludeTouchSupport) {
      keys.push({
        key: "touch_support",
        value: this.getTouchSupport()
      });
    }

    return keys;
  },
  hardwareConcurrencyKey: function hardwareConcurrencyKey(keys) {
    if (!this.options.excludeHardwareConcurrency) {
      keys.push({
        key: "hardware_concurrency",
        value: this.getHardwareConcurrency()
      });
    }

    return keys;
  },
  hasSessionStorage: function hasSessionStorage() {
    try {
      return !!window.sessionStorage;
    } catch (e) {
      return true; // SecurityError when referencing it means it exists
    }
  },
  // https://bugzilla.mozilla.org/show_bug.cgi?id=781447
  hasLocalStorage: function hasLocalStorage() {
    try {
      return !!window.localStorage;
    } catch (e) {
      return true; // SecurityError when referencing it means it exists
    }
  },
  hasIndexedDB: function hasIndexedDB() {
    try {
      return !!window.indexedDB;
    } catch (e) {
      return true; // SecurityError when referencing it means it exists
    }
  },
  getHardwareConcurrency: function getHardwareConcurrency() {
    if (navigator.hardwareConcurrency) {
      return navigator.hardwareConcurrency;
    }

    return "unknown";
  },
  getNavigatorCpuClass: function getNavigatorCpuClass() {
    if (navigator.cpuClass) {
      return navigator.cpuClass;
    } else {
      return "unknown";
    }
  },
  getNavigatorPlatform: function getNavigatorPlatform() {
    if (navigator.platform) {
      return navigator.platform;
    } else {
      return "unknown";
    }
  },
  getDoNotTrack: function getDoNotTrack() {
    if (navigator.doNotTrack) {
      return navigator.doNotTrack;
    } else if (navigator.msDoNotTrack) {
      return navigator.msDoNotTrack;
    } else if (window.doNotTrack) {
      return window.doNotTrack;
    } else {
      return "unknown";
    }
  },
  // This is a crude and primitive touch screen detection.
  // It's not possible to currently reliably detect the  availability of a touch screen
  // with a JS, without actually subscribing to a touch event.
  // http://www.stucox.com/blog/you-cant-detect-a-touchscreen/
  // https://github.com/Modernizr/Modernizr/issues/548
  // method returns an array of 3 values:
  // maxTouchPoints, the success or failure of creating a TouchEvent,
  // and the availability of the 'ontouchstart' property
  getTouchSupport: function getTouchSupport() {
    var maxTouchPoints = 0;
    var touchEvent = false;

    if (typeof navigator.maxTouchPoints !== "undefined") {
      maxTouchPoints = navigator.maxTouchPoints;
    } else if (typeof navigator.msMaxTouchPoints !== "undefined") {
      maxTouchPoints = navigator.msMaxTouchPoints;
    }

    try {
      document.createEvent("TouchEvent");
      touchEvent = true;
    } catch (_) {
      /* squelch */
    }

    var touchStart = ("ontouchstart" in window);
    return [maxTouchPoints, touchEvent, touchStart];
  },
  // https://www.browserleaks.com/canvas#how-does-it-work
  getCanvasFp: function getCanvasFp() {
    var result = []; // Very simple now, need to make it more complex (geo shapes etc)

    var canvas = document.createElement("canvas");
    canvas.width = 2000;
    canvas.height = 200;
    canvas.style.display = "inline";
    var ctx = canvas.getContext("2d"); // detect browser support of canvas winding
    // http://blogs.adobe.com/webplatform/2013/01/30/winding-rules-in-canvas/
    // https://github.com/Modernizr/Modernizr/blob/master/feature-detects/canvas/winding.js

    ctx.rect(0, 0, 10, 10);
    ctx.rect(2, 2, 6, 6);
    result.push("canvas winding:" + (ctx.isPointInPath(5, 5, "evenodd") === false ? "yes" : "no"));
    ctx.textBaseline = "alphabetic";
    ctx.fillStyle = "#f60";
    ctx.fillRect(125, 1, 62, 20);
    ctx.fillStyle = "#069"; // https://github.com/Valve/fingerprintjs2/issues/66

    if (this.options.dontUseFakeFontInCanvas) {
      ctx.font = "11pt Arial";
    } else {
      ctx.font = "11pt no-real-font-123";
    }

    ctx.fillText("Cwm fjordbank glyphs vext quiz, \uD83D\uDE03", 2, 15);
    ctx.fillStyle = "rgba(102, 204, 0, 0.2)";
    ctx.font = "18pt Arial";
    ctx.fillText("Cwm fjordbank glyphs vext quiz, \uD83D\uDE03", 4, 45); // canvas blending
    // http://blogs.adobe.com/webplatform/2013/01/28/blending-features-in-canvas/
    // http://jsfiddle.net/NDYV8/16/

    ctx.globalCompositeOperation = "multiply";
    ctx.fillStyle = "rgb(255,0,255)";
    ctx.beginPath();
    ctx.arc(50, 50, 50, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "rgb(0,255,255)";
    ctx.beginPath();
    ctx.arc(100, 50, 50, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "rgb(255,255,0)";
    ctx.beginPath();
    ctx.arc(75, 100, 50, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = "rgb(255,0,255)"; // canvas winding
    // http://blogs.adobe.com/webplatform/2013/01/30/winding-rules-in-canvas/
    // http://jsfiddle.net/NDYV8/19/

    ctx.arc(75, 75, 75, 0, Math.PI * 2, true);
    ctx.arc(75, 75, 25, 0, Math.PI * 2, true);
    ctx.fill("evenodd");
    result.push("canvas fp:" + canvas.toDataURL());
    return result.join("~");
  },
  getWebglFp: function getWebglFp() {
    var gl;

    var fa2s = function fa2s(fa) {
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      return "[" + fa[0] + ", " + fa[1] + "]";
    };

    var maxAnisotropy = function maxAnisotropy(gl) {
      var anisotropy,
          ext = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic");
      return ext ? (anisotropy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT), 0 === anisotropy && (anisotropy = 2), anisotropy) : null;
    };

    gl = this.getWebglCanvas();

    if (!gl) {
      return null;
    } // WebGL fingerprinting is a combination of techniques, found in MaxMind antifraud script & Augur fingerprinting.
    // First it draws a gradient object with shaders and convers the image to the Base64 string.
    // Then it enumerates all WebGL extensions & capabilities and appends them to the Base64 string, resulting in a huge WebGL string, potentially very unique on each device
    // Since iOS supports webgl starting from version 8.1 and 8.1 runs on several graphics chips, the results may be different across ios devices, but we need to verify it.


    var result = [];
    var vShaderTemplate = "attribute vec2 attrVertex;varying vec2 varyinTexCoordinate;uniform vec2 uniformOffset;void main(){varyinTexCoordinate=attrVertex+uniformOffset;gl_Position=vec4(attrVertex,0,1);}";
    var fShaderTemplate = "precision mediump float;varying vec2 varyinTexCoordinate;void main() {gl_FragColor=vec4(varyinTexCoordinate,0,1);}";
    var vertexPosBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
    var vertices = new Float32Array([-.2, -.9, 0, .4, -.26, 0, 0, .732134444, 0]);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    vertexPosBuffer.itemSize = 3;
    vertexPosBuffer.numItems = 3;
    var program = gl.createProgram(),
        vshader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vshader, vShaderTemplate);
    gl.compileShader(vshader);
    var fshader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fshader, fShaderTemplate);
    gl.compileShader(fshader);
    gl.attachShader(program, vshader);
    gl.attachShader(program, fshader);
    gl.linkProgram(program);
    gl.useProgram(program);
    program.vertexPosAttrib = gl.getAttribLocation(program, "attrVertex");
    program.offsetUniform = gl.getUniformLocation(program, "uniformOffset");
    gl.enableVertexAttribArray(program.vertexPosArray);
    gl.vertexAttribPointer(program.vertexPosAttrib, vertexPosBuffer.itemSize, gl.FLOAT, !1, 0, 0);
    gl.uniform2f(program.offsetUniform, 1, 1);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertexPosBuffer.numItems);

    if (gl.canvas != null) {
      result.push(gl.canvas.toDataURL());
    }

    result.push("extensions:" + gl.getSupportedExtensions().join(";"));
    result.push("webgl aliased line width range:" + fa2s(gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE)));
    result.push("webgl aliased point size range:" + fa2s(gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE)));
    result.push("webgl alpha bits:" + gl.getParameter(gl.ALPHA_BITS));
    result.push("webgl antialiasing:" + (gl.getContextAttributes().antialias ? "yes" : "no"));
    result.push("webgl blue bits:" + gl.getParameter(gl.BLUE_BITS));
    result.push("webgl depth bits:" + gl.getParameter(gl.DEPTH_BITS));
    result.push("webgl green bits:" + gl.getParameter(gl.GREEN_BITS));
    result.push("webgl max anisotropy:" + maxAnisotropy(gl));
    result.push("webgl max combined texture image units:" + gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS));
    result.push("webgl max cube map texture size:" + gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE));
    result.push("webgl max fragment uniform vectors:" + gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS));
    result.push("webgl max render buffer size:" + gl.getParameter(gl.MAX_RENDERBUFFER_SIZE));
    result.push("webgl max texture image units:" + gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
    result.push("webgl max texture size:" + gl.getParameter(gl.MAX_TEXTURE_SIZE));
    result.push("webgl max varying vectors:" + gl.getParameter(gl.MAX_VARYING_VECTORS));
    result.push("webgl max vertex attribs:" + gl.getParameter(gl.MAX_VERTEX_ATTRIBS));
    result.push("webgl max vertex texture image units:" + gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS));
    result.push("webgl max vertex uniform vectors:" + gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS));
    result.push("webgl max viewport dims:" + fa2s(gl.getParameter(gl.MAX_VIEWPORT_DIMS)));
    result.push("webgl red bits:" + gl.getParameter(gl.RED_BITS));
    result.push("webgl renderer:" + gl.getParameter(gl.RENDERER));
    result.push("webgl shading language version:" + gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
    result.push("webgl stencil bits:" + gl.getParameter(gl.STENCIL_BITS));
    result.push("webgl vendor:" + gl.getParameter(gl.VENDOR));
    result.push("webgl version:" + gl.getParameter(gl.VERSION));

    try {
      // Add the unmasked vendor and unmasked renderer if the debug_renderer_info extension is available
      var extensionDebugRendererInfo = gl.getExtension("WEBGL_debug_renderer_info");

      if (extensionDebugRendererInfo) {
        result.push("webgl unmasked vendor:" + gl.getParameter(extensionDebugRendererInfo.UNMASKED_VENDOR_WEBGL));
        result.push("webgl unmasked renderer:" + gl.getParameter(extensionDebugRendererInfo.UNMASKED_RENDERER_WEBGL));
      }
    } catch (e) {
      /* squelch */
    }

    if (!gl.getShaderPrecisionFormat) {
      return result.join("~");
    }

    result.push("webgl vertex shader high float precision:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision);
    result.push("webgl vertex shader high float precision rangeMin:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMin);
    result.push("webgl vertex shader high float precision rangeMax:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMax);
    result.push("webgl vertex shader medium float precision:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision);
    result.push("webgl vertex shader medium float precision rangeMin:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMin);
    result.push("webgl vertex shader medium float precision rangeMax:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMax);
    result.push("webgl vertex shader low float precision:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).precision);
    result.push("webgl vertex shader low float precision rangeMin:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMin);
    result.push("webgl vertex shader low float precision rangeMax:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMax);
    result.push("webgl fragment shader high float precision:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision);
    result.push("webgl fragment shader high float precision rangeMin:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMin);
    result.push("webgl fragment shader high float precision rangeMax:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMax);
    result.push("webgl fragment shader medium float precision:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision);
    result.push("webgl fragment shader medium float precision rangeMin:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMin);
    result.push("webgl fragment shader medium float precision rangeMax:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMax);
    result.push("webgl fragment shader low float precision:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).precision);
    result.push("webgl fragment shader low float precision rangeMin:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMin);
    result.push("webgl fragment shader low float precision rangeMax:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMax);
    result.push("webgl vertex shader high int precision:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).precision);
    result.push("webgl vertex shader high int precision rangeMin:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMin);
    result.push("webgl vertex shader high int precision rangeMax:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMax);
    result.push("webgl vertex shader medium int precision:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).precision);
    result.push("webgl vertex shader medium int precision rangeMin:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMin);
    result.push("webgl vertex shader medium int precision rangeMax:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMax);
    result.push("webgl vertex shader low int precision:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).precision);
    result.push("webgl vertex shader low int precision rangeMin:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMin);
    result.push("webgl vertex shader low int precision rangeMax:" + gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMax);
    result.push("webgl fragment shader high int precision:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).precision);
    result.push("webgl fragment shader high int precision rangeMin:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMin);
    result.push("webgl fragment shader high int precision rangeMax:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMax);
    result.push("webgl fragment shader medium int precision:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).precision);
    result.push("webgl fragment shader medium int precision rangeMin:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMin);
    result.push("webgl fragment shader medium int precision rangeMax:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMax);
    result.push("webgl fragment shader low int precision:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).precision);
    result.push("webgl fragment shader low int precision rangeMin:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMin);
    result.push("webgl fragment shader low int precision rangeMax:" + gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMax);
    return result.join("~");
  },
  getAdBlock: function getAdBlock() {
    var ads = document.createElement("div");
    ads.innerHTML = "&nbsp;";
    ads.className = "adsbox";
    var result = false;

    try {
      // body may not exist, that's why we need try/catch
      document.body.appendChild(ads);
      result = document.getElementsByClassName("adsbox")[0].offsetHeight === 0;
      document.body.removeChild(ads);
    } catch (e) {
      result = false;
    }

    return result;
  },
  getHasLiedLanguages: function getHasLiedLanguages() {
    //We check if navigator.language is equal to the first language of navigator.languages
    if (typeof navigator.languages !== "undefined") {
      try {
        var firstLanguages = navigator.languages[0].substr(0, 2);

        if (firstLanguages !== navigator.language.substr(0, 2)) {
          return true;
        }
      } catch (err) {
        return true;
      }
    }

    return false;
  },
  getHasLiedResolution: function getHasLiedResolution() {
    if (screen.width < screen.availWidth) {
      return true;
    }

    if (screen.height < screen.availHeight) {
      return true;
    }

    return false;
  },
  getHasLiedOs: function getHasLiedOs() {
    var userAgent = navigator.userAgent.toLowerCase();
    var oscpu = navigator.oscpu;
    var platform = navigator.platform.toLowerCase();
    var os; //We extract the OS from the user agent (respect the order of the if else if statement)

    if (userAgent.indexOf("windows phone") >= 0) {
      os = "Windows Phone";
    } else if (userAgent.indexOf("win") >= 0) {
      os = "Windows";
    } else if (userAgent.indexOf("android") >= 0) {
      os = "Android";
    } else if (userAgent.indexOf("linux") >= 0) {
      os = "Linux";
    } else if (userAgent.indexOf("iphone") >= 0 || userAgent.indexOf("ipad") >= 0) {
      os = "iOS";
    } else if (userAgent.indexOf("mac") >= 0) {
      os = "Mac";
    } else {
      os = "Other";
    } // We detect if the person uses a mobile device


    var mobileDevice;

    if ("ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0) {
      mobileDevice = true;
    } else {
      mobileDevice = false;
    }

    if (mobileDevice && os !== "Windows Phone" && os !== "Android" && os !== "iOS" && os !== "Other") {
      return true;
    } // We compare oscpu with the OS extracted from the UA


    if (typeof oscpu !== "undefined") {
      oscpu = oscpu.toLowerCase();

      if (oscpu.indexOf("win") >= 0 && os !== "Windows" && os !== "Windows Phone") {
        return true;
      } else if (oscpu.indexOf("linux") >= 0 && os !== "Linux" && os !== "Android") {
        return true;
      } else if (oscpu.indexOf("mac") >= 0 && os !== "Mac" && os !== "iOS") {
        return true;
      } else if (oscpu.indexOf("win") === 0 && oscpu.indexOf("linux") === 0 && oscpu.indexOf("mac") >= 0 && os !== "other") {
        return true;
      }
    } //We compare platform with the OS extracted from the UA


    if (platform.indexOf("win") >= 0 && os !== "Windows" && os !== "Windows Phone") {
      return true;
    } else if ((platform.indexOf("linux") >= 0 || platform.indexOf("android") >= 0 || platform.indexOf("pike") >= 0) && os !== "Linux" && os !== "Android") {
      return true;
    } else if ((platform.indexOf("mac") >= 0 || platform.indexOf("ipad") >= 0 || platform.indexOf("ipod") >= 0 || platform.indexOf("iphone") >= 0) && os !== "Mac" && os !== "iOS") {
      return true;
    } else if (platform.indexOf("win") === 0 && platform.indexOf("linux") === 0 && platform.indexOf("mac") >= 0 && os !== "other") {
      return true;
    }

    if (typeof navigator.plugins === "undefined" && os !== "Windows" && os !== "Windows Phone") {
      //We are are in the case where the person uses ie, therefore we can infer that it's windows
      return true;
    }

    return false;
  },
  getHasLiedBrowser: function getHasLiedBrowser() {
    var userAgent = navigator.userAgent.toLowerCase();
    var productSub = navigator.productSub; //we extract the browser from the user agent (respect the order of the tests)

    var browser;

    if (userAgent.indexOf("firefox") >= 0) {
      browser = "Firefox";
    } else if (userAgent.indexOf("opera") >= 0 || userAgent.indexOf("opr") >= 0) {
      browser = "Opera";
    } else if (userAgent.indexOf("chrome") >= 0) {
      browser = "Chrome";
    } else if (userAgent.indexOf("safari") >= 0) {
      browser = "Safari";
    } else if (userAgent.indexOf("trident") >= 0) {
      browser = "Internet Explorer";
    } else {
      browser = "Other";
    }

    if ((browser === "Chrome" || browser === "Safari" || browser === "Opera") && productSub !== "20030107") {
      return true;
    }

    var tempRes = eval.toString().length;

    if (tempRes === 37 && browser !== "Safari" && browser !== "Firefox" && browser !== "Other") {
      return true;
    } else if (tempRes === 39 && browser !== "Internet Explorer" && browser !== "Other") {
      return true;
    } else if (tempRes === 33 && browser !== "Chrome" && browser !== "Opera" && browser !== "Other") {
      return true;
    } //We create an error to see how it is handled


    var errFirefox;

    try {
      throw "a";
    } catch (err) {
      try {
        err.toSource();
        errFirefox = true;
      } catch (errOfErr) {
        errFirefox = false;
      }
    }

    if (errFirefox && browser !== "Firefox" && browser !== "Other") {
      return true;
    }

    return false;
  },
  isCanvasSupported: function isCanvasSupported() {
    var elem = document.createElement("canvas");
    return !!(elem.getContext && elem.getContext("2d"));
  },
  isWebGlSupported: function isWebGlSupported() {
    // code taken from Modernizr
    if (!this.isCanvasSupported()) {
      return false;
    }

    var canvas = document.createElement("canvas"),
        glContext;

    try {
      glContext = canvas.getContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl"));
    } catch (e) {
      glContext = false;
    }

    return !!window.WebGLRenderingContext && !!glContext;
  },
  isIE: function isIE() {
    if (navigator.appName === "Microsoft Internet Explorer") {
      return true;
    } else if (navigator.appName === "Netscape" && /Trident/.test(navigator.userAgent)) {
      // IE 11
      return true;
    }

    return false;
  },
  hasSwfObjectLoaded: function hasSwfObjectLoaded() {
    return typeof window.swfobject !== "undefined";
  },
  hasMinFlashInstalled: function hasMinFlashInstalled() {
    return swfobject.hasFlashPlayerVersion("9.0.0");
  },
  addFlashDivNode: function addFlashDivNode() {
    var node = document.createElement("div");
    node.setAttribute("id", this.options.swfContainerId);
    document.body.appendChild(node);
  },
  getWebglCanvas: function getWebglCanvas() {
    var canvas = document.createElement("canvas");
    var gl = null;

    try {
      gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    } catch (e) {
      /* squelch */
    }

    if (!gl) {
      gl = null;
    }

    return gl;
  },
  each: function each(obj, iterator, context) {
    if (obj === null) {
      return;
    }

    if (this.nativeForEach && obj.forEach === this.nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === {}) {
          return;
        }
      }
    } else {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (iterator.call(context, obj[key], key, obj) === {}) {
            return;
          }
        }
      }
    }
  },
  map: function map(obj, iterator, context) {
    var results = []; // Not using strict equality so that this acts as a
    // shortcut to checking for `null` and `undefined`.

    if (obj == null) {
      return results;
    }

    if (this.nativeMap && obj.map === this.nativeMap) {
      return obj.map(iterator, context);
    }

    this.each(obj, function (value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  },
  /// MurmurHash3 related functions
  //
  // Given two 64bit ints (as an array of two 32bit ints) returns the two
  // added together as a 64bit int (as an array of two 32bit ints).
  //
  x64Add: function x64Add(m, n) {
    m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];
    n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];
    var o = [0, 0, 0, 0];
    o[3] += m[3] + n[3];
    o[2] += o[3] >>> 16;
    o[3] &= 0xffff;
    o[2] += m[2] + n[2];
    o[1] += o[2] >>> 16;
    o[2] &= 0xffff;
    o[1] += m[1] + n[1];
    o[0] += o[1] >>> 16;
    o[1] &= 0xffff;
    o[0] += m[0] + n[0];
    o[0] &= 0xffff;
    return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
  },
  //
  // Given two 64bit ints (as an array of two 32bit ints) returns the two
  // multiplied together as a 64bit int (as an array of two 32bit ints).
  //
  x64Multiply: function x64Multiply(m, n) {
    m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];
    n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];
    var o = [0, 0, 0, 0];
    o[3] += m[3] * n[3];
    o[2] += o[3] >>> 16;
    o[3] &= 0xffff;
    o[2] += m[2] * n[3];
    o[1] += o[2] >>> 16;
    o[2] &= 0xffff;
    o[2] += m[3] * n[2];
    o[1] += o[2] >>> 16;
    o[2] &= 0xffff;
    o[1] += m[1] * n[3];
    o[0] += o[1] >>> 16;
    o[1] &= 0xffff;
    o[1] += m[2] * n[2];
    o[0] += o[1] >>> 16;
    o[1] &= 0xffff;
    o[1] += m[3] * n[1];
    o[0] += o[1] >>> 16;
    o[1] &= 0xffff;
    o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
    o[0] &= 0xffff;
    return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
  },
  //
  // Given a 64bit int (as an array of two 32bit ints) and an int
  // representing a number of bit positions, returns the 64bit int (as an
  // array of two 32bit ints) rotated left by that number of positions.
  //
  x64Rotl: function x64Rotl(m, n) {
    n %= 64;

    if (n === 32) {
      return [m[1], m[0]];
    } else if (n < 32) {
      return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
    } else {
      n -= 32;
      return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
    }
  },
  //
  // Given a 64bit int (as an array of two 32bit ints) and an int
  // representing a number of bit positions, returns the 64bit int (as an
  // array of two 32bit ints) shifted left by that number of positions.
  //
  x64LeftShift: function x64LeftShift(m, n) {
    n %= 64;

    if (n === 0) {
      return m;
    } else if (n < 32) {
      return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
    } else {
      return [m[1] << n - 32, 0];
    }
  },
  //
  // Given two 64bit ints (as an array of two 32bit ints) returns the two
  // xored together as a 64bit int (as an array of two 32bit ints).
  //
  x64Xor: function x64Xor(m, n) {
    return [m[0] ^ n[0], m[1] ^ n[1]];
  },
  //
  // Given a block, returns murmurHash3's final x64 mix of that block.
  // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the
  // only place where we need to right shift 64bit ints.)
  //
  x64Fmix: function x64Fmix(h) {
    h = this.x64Xor(h, [0, h[0] >>> 1]);
    h = this.x64Multiply(h, [0xff51afd7, 0xed558ccd]);
    h = this.x64Xor(h, [0, h[0] >>> 1]);
    h = this.x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);
    h = this.x64Xor(h, [0, h[0] >>> 1]);
    return h;
  },
  //
  // Given a string and an optional seed as an int, returns a 128 bit
  // hash using the x64 flavor of MurmurHash3, as an unsigned hex.
  //
  x64hash128: function x64hash128(key, seed) {
    key = key || "";
    seed = seed || 0;
    var remainder = key.length % 16;
    var bytes = key.length - remainder;
    var h1 = [0, seed];
    var h2 = [0, seed];
    var k1 = [0, 0];
    var k2 = [0, 0];
    var c1 = [0x87c37b91, 0x114253d5];
    var c2 = [0x4cf5ad43, 0x2745937f];

    for (var i = 0; i < bytes; i = i + 16) {
      k1 = [key.charCodeAt(i + 4) & 0xff | (key.charCodeAt(i + 5) & 0xff) << 8 | (key.charCodeAt(i + 6) & 0xff) << 16 | (key.charCodeAt(i + 7) & 0xff) << 24, key.charCodeAt(i) & 0xff | (key.charCodeAt(i + 1) & 0xff) << 8 | (key.charCodeAt(i + 2) & 0xff) << 16 | (key.charCodeAt(i + 3) & 0xff) << 24];
      k2 = [key.charCodeAt(i + 12) & 0xff | (key.charCodeAt(i + 13) & 0xff) << 8 | (key.charCodeAt(i + 14) & 0xff) << 16 | (key.charCodeAt(i + 15) & 0xff) << 24, key.charCodeAt(i + 8) & 0xff | (key.charCodeAt(i + 9) & 0xff) << 8 | (key.charCodeAt(i + 10) & 0xff) << 16 | (key.charCodeAt(i + 11) & 0xff) << 24];
      k1 = this.x64Multiply(k1, c1);
      k1 = this.x64Rotl(k1, 31);
      k1 = this.x64Multiply(k1, c2);
      h1 = this.x64Xor(h1, k1);
      h1 = this.x64Rotl(h1, 27);
      h1 = this.x64Add(h1, h2);
      h1 = this.x64Add(this.x64Multiply(h1, [0, 5]), [0, 0x52dce729]);
      k2 = this.x64Multiply(k2, c2);
      k2 = this.x64Rotl(k2, 33);
      k2 = this.x64Multiply(k2, c1);
      h2 = this.x64Xor(h2, k2);
      h2 = this.x64Rotl(h2, 31);
      h2 = this.x64Add(h2, h1);
      h2 = this.x64Add(this.x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);
    }

    k1 = [0, 0];
    k2 = [0, 0];

    switch (remainder) {
      case 15:
        k2 = this.x64Xor(k2, this.x64LeftShift([0, key.charCodeAt(i + 14)], 48));

      case 14:
        k2 = this.x64Xor(k2, this.x64LeftShift([0, key.charCodeAt(i + 13)], 40));

      case 13:
        k2 = this.x64Xor(k2, this.x64LeftShift([0, key.charCodeAt(i + 12)], 32));

      case 12:
        k2 = this.x64Xor(k2, this.x64LeftShift([0, key.charCodeAt(i + 11)], 24));

      case 11:
        k2 = this.x64Xor(k2, this.x64LeftShift([0, key.charCodeAt(i + 10)], 16));

      case 10:
        k2 = this.x64Xor(k2, this.x64LeftShift([0, key.charCodeAt(i + 9)], 8));

      case 9:
        k2 = this.x64Xor(k2, [0, key.charCodeAt(i + 8)]);
        k2 = this.x64Multiply(k2, c2);
        k2 = this.x64Rotl(k2, 33);
        k2 = this.x64Multiply(k2, c1);
        h2 = this.x64Xor(h2, k2);

      case 8:
        k1 = this.x64Xor(k1, this.x64LeftShift([0, key.charCodeAt(i + 7)], 56));

      case 7:
        k1 = this.x64Xor(k1, this.x64LeftShift([0, key.charCodeAt(i + 6)], 48));

      case 6:
        k1 = this.x64Xor(k1, this.x64LeftShift([0, key.charCodeAt(i + 5)], 40));

      case 5:
        k1 = this.x64Xor(k1, this.x64LeftShift([0, key.charCodeAt(i + 4)], 32));

      case 4:
        k1 = this.x64Xor(k1, this.x64LeftShift([0, key.charCodeAt(i + 3)], 24));

      case 3:
        k1 = this.x64Xor(k1, this.x64LeftShift([0, key.charCodeAt(i + 2)], 16));

      case 2:
        k1 = this.x64Xor(k1, this.x64LeftShift([0, key.charCodeAt(i + 1)], 8));

      case 1:
        k1 = this.x64Xor(k1, [0, key.charCodeAt(i)]);
        k1 = this.x64Multiply(k1, c1);
        k1 = this.x64Rotl(k1, 31);
        k1 = this.x64Multiply(k1, c2);
        h1 = this.x64Xor(h1, k1);
    }

    h1 = this.x64Xor(h1, [0, key.length]);
    h2 = this.x64Xor(h2, [0, key.length]);
    h1 = this.x64Add(h1, h2);
    h2 = this.x64Add(h2, h1);
    h1 = this.x64Fmix(h1);
    h2 = this.x64Fmix(h2);
    h1 = this.x64Add(h1, h2);
    h2 = this.x64Add(h2, h1);
    return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
  }
};
Fingerprint2.VERSION = "1.5.1";

/**
 * Created by dfzq on 2017/3/24.
 */
/**
 * 存储授权token
 * @param response 响应值
 */

var tokenKey = configuration.tokenKey;
var stateKey = '__login__'; // let deviceIdKey = '__d__'//旧版本指纹

var deviceIdKey = '__d2__'; //由于指纹升级，新建一个key

var storeAuthorizationToken = function storeAuthorizationToken(response, funcNo) {
  try {
    // 针对不检查登录态的接口不覆盖token
    if (configuration.api[funcNo]) {
      if (response.entity.payload.code === 0) {
        if (!!response.entity.header.token) {
          // 判断当前是否localStorage是否存放了token
          var tokenStorage = store.get(tokenKey); // 查询当前所存储的token是否与目前回传的一致，如果不一致执行刷新

          if (tokenStorage != response.entity.header.token) {
            store.set(tokenKey, response.entity.header.token);
          }
        }
      }
    }
  } catch (ex) {
    return when.reject({
      response: response,
      error: 'storeerror'
    });
  }
};
/**
 * 登录状态
 * @param response
 */


var storeLoginStatus = function storeLoginStatus(response, funcNo) {
  try {
    if (configuration.api[funcNo]) {
      var currentState = store.get(stateKey);

      if (currentState != response.entity.header.state) {
        store.set(stateKey, response.entity.header.state);
      }
    }
  } catch (e) {}
};
/**
 * 让mock支持自定义参数功能(即通过不同的get参数来返回不同的输出结果)
 * @param url 待解析的url
 * @param config 拦截请求的相关配置
 * @param request 请求
 */


var wrapMockEnv = function wrapMockEnv(url, config, request) {
  url += config.funcNo;
  var q = 0;

  for (var i in request.entity) {
    if (q == 0) {
      url += '?';
    }

    q++;
    url += i + '=' + request.entity[i];
    url += '&';
  }

  if (url.lastIndexOf('&') == url.length - 1) {
    url = url.substring(0, url.length - 1);
  }

  return url;
};
/**
 * 对中台数据结构进行转化
 * {
                "header": {
                    "appId": "xxxxx",           //颁发给接口调用者的唯一凭证
                    "ver": "1.0",               //应用客户端版本
                    "channel": "xxx",           //渠道来源:包括WECHAT,PC,IOS,ANDROID
                    "deviceId": "xxxx",         //移动端需要传递设备号;PC和微信暂不用传递
                    "opStation": "xxx",         //MAC地址或IP地址
                    "funcNo": "IF010000",       //功能号
                    "timestamp": 999,           //请求时间戳
                    "funcVer": "4",             //服务端版本
                },
                "payload": "xxx",               //业务Json格式字符串
                "sign": "xxx"                   //签名
            }
 *
 */


var appId = configuration.appId; // let channel = configuration.channel
// 默认其他 20200605 linyiqing 默认渠道为1，新增网厅渠道为24

var channel = '1';

try {
  // 根据渠道区分
  if (isFromApp()) {
    if (detectUtil.os.ios) {
      // ios
      channel = '12';
    } else if (detectUtil.os.android) {
      // 安卓
      channel = '17';
    }
  } else if (isFromWeiXin()) {
    // 微信
    channel = '13';
  } else if (APPTYPE == 'wangting') {
    // 网厅
    channel = '24';
  }
} catch (err) {}

var domain = configuration.domain;
var port = configuration.port || 80;
var urlPort = port === 80 ? '' : ":".concat(port);
var funcVer = configuration.funcVer;

var warpMessageEntity = function warpMessageEntity(request, config) {
  // 访问路径解析
  var api = configuration.api[config.funcNo];

  if (!api) {
    console.error("".concat(config.funcNo, " not defined"));
  }

  if (!api.hasOwnProperty("path")) {
    console.error("path of ".concat(config.funcNo, " not defined"));
  } // 查询接口对应path


  var path = configuration[api.path];
  var url = "".concat(domain + urlPort + path);

  if (configuration.appEnv === 'mock') {
    url = wrapMockEnv(url, config, request);
    request.path = url;
  } else {
    // url中是否包含platform参数，有platform参数
    if (url.indexOf('platform') == -1) {
      var platformName = ''; // app

      if (isFromApp()) {
        // ios
        if (detectUtil.os.ios) {
          platformName = 'ios';
        } // android
        else if (detectUtil.os.android) {
            platformName = 'android';
          }
      } else {
        // 微信
        if (isFromWeiXin()) {
          platformName = 'weixin';
        } // 其他端
        else {
            platformName = 'other';
          }
      }

      if (url.match('[\?]')) {
        url += '&platform=' + platformName;
      } else {
        url += '?platform=' + platformName;
      }

      url += '&version=' + configuration.funcVer;
    } // 增加统一api中的func参数，由func来路由对应的gateway


    request.path = url + '&func=' + config.funcNo;
  }

  var body = {
    header: {
      appId: appId,
      ver: getVersion() || '1.0',
      // 如channel == "1"，代表未命中，则使用配置文件中的channel
      channel: channel == "1" ? config.channel : channel,
      funcNo: config.funcNo,
      timestamp: new Date().getTime(),
      funcVer: funcVer
    },
    payload: request.entity,
    sign: ''
  }; // // 新增authSign，用于接口恢复用户信息 //
  // if (!!AppAuthorize.authSign) {
  //     body.header.auth = AppAuthorize.authSign
  // }
  // 2020-12-28:新增 refreshToken 方案，替换原 authSign

  if (!!AppAuthorize$1.newAuthSign) {
    body.header.auth = AppAuthorize$1.newAuthSign;
  } // 微信授权机制 //


  var tokenStorage = store.get(tokenKey);
  if (!!tokenStorage) body.header.token = tokenStorage; // // DeviceId //
  // if(configuration.appEnv !== 'dist' && configuration.appEnv !== 'uat'){
  //     var deviceIDStorage = store.get('__deviceid__')
  //     if(!!deviceIDStorage)
  //         body.header.deviceId = deviceIDStorage
  // }
  // 非APP增加deviceId属性，APP则使用vtDeviceId属性。

  if (!isFromApp()) {
    // 增加opstation属性
    body.header.opStation = '33333333333'; // 微信接入时opStation设置为微信的OpenID

    if (isFromWeiXin()) {
      if (AppAuthorize$1.openId) {
        body.header.opStation = AppAuthorize$1.openId;
      }
    } // TODO 增加deviceid机制


    var d = store.get(deviceIdKey);

    if (!!d) {
      body.header.deviceId = d + '';
    } else {
      //旧版本指纹，生成的指纹较短
      // let deviceId = new Fingerprint({canvas: true}).get() + ''
      var deviceId = new Fingerprint2().getSync().fprint + '';

      if (!!(deviceId != null && (!!deviceId.length ? true : deviceId.length > 0))) {
        store.set(deviceIdKey, deviceId);
        body.header.deviceId = deviceId;
      }
    }
  }

  request.entity = body;
  return request;
};

var transformInterceptor = interceptor({
  /**
   * @field funcNo {string} 调用中台的功能号，用于应用层路由
   * @field messageEntity {object/string} 消息体，可能是一个字符串也可能是一个对象
   *
   * @class config
   */
  init: function init(config) {
    return config;
  },
  request: function request(_request, config) {
    return warpMessageEntity(_request, config);
  },
  response: function response(_response, config) {
    // 通讯相关错误直接抛到上层处理
    if (_response.error) {
      return _response;
    } // 存储token


    storeAuthorizationToken(_response, config.funcNo); // 存储登录状态

    storeLoginStatus(_response, config.funcNo); // // 每次响应都需要刷新state登录态
    // var state = response.entity.header.state;
    // if(typeof state == 'boolean'){
    //     store.set('__s__', state);
    // }
    // 赋值该响应归属于哪个api

    if (!_response.funcNo) _response.funcNo = config.funcNo;
    return _response;
  }
});

/*
 * @Author: shenzhiwei
 * @Date: 2019-07-17 10:48:58
 * @LastEditors: shenzhiwei
 * @LastEditTime: 2019-07-27 09:40:36
 * @Description: 针对restful接口进行业务数据结构转化的拦截器定义
 */
/** 
 * 获取uid和deviceId
 * uid：AppAuthorize.cifAccount || AppAuthorize.regAccount || AppAuthorize.fundAccount || '', 且根据对应的账户类型在uid前加上对应的字母
 * deviceId：app中AppAuthorize.vtDeviceId，非app拿store中的__d2__,若取不到vtDeviceId或__d2__，则自动生成uuid作为deviceId
*/

var ticketGenerator = function ticketGenerator() {
  var uid = (AppAuthorize$1.cifAccount ? 'C' + AppAuthorize$1.cifAccount : '') || (AppAuthorize$1.regAccount ? 'R' + AppAuthorize$1.regAccount : '') || (AppAuthorize$1.fundAccount ? 'B' + AppAuthorize$1.fundAccount : '');
  var deviceId = null;

  if (isFromApp()) {
    deviceId = AppAuthorize$1.vtDeviceId || getGuid();
    console.log('uid ' + uid + 'deviceId ' + deviceId);
  } else {
    deviceId = store.get(deviceIdKey) || getGuid();
    console.log('uid ' + uid + 'deviceId ' + deviceId);
  }

  return {
    uid: uid,
    deviceId: deviceId
  };
};
/**
 * 让mock支持自定义参数功能(即通过不同的get参数来返回不同的输出结果)
 * @param url 待解析的url
 * @param config 拦截请求的相关配置
 * @param request 请求
 */


var wrapMockEnv$1 = function wrapMockEnv(url, config, request) {
  url += config.funcNo;
  var q = 0;

  for (var i in request.entity) {
    if (q == 0) {
      url += '?';
    }

    q++;
    url += i + '=' + request.entity[i];
    url += '&';
  }

  if (url.lastIndexOf('&') == url.length - 1) {
    url = url.substring(0, url.length - 1);
  }

  return url;
};
/**
 * 对中台数据结构进行转化
 * {
 *    uid: xxxx,
 *    deviceId: xxxx,
 *    业务字段: xxxx
 * }
 *
 */


var domain$1 = configuration.domain;
var port$1 = configuration.port || 80;
var urlPort$1 = port$1 === 80 ? '' : ":".concat(port$1);
var funcVer$1 = configuration.funcVer;

var warpMessageEntity$1 = function warpMessageEntity(request, config) {
  // 访问路径解析
  var api = configuration.api[config.funcNo];

  if (!api) {
    console.error("".concat(config.funcNo, " not defined"));
  }

  if (!api.hasOwnProperty("path")) {
    console.error("path of ".concat(config.funcNo, " not defined"));
  } // 查询接口对应path


  var path = configuration[api.path];
  var url = "".concat(domain$1 + urlPort$1 + path);

  if (configuration.appEnv === 'mock') {
    url = wrapMockEnv$1(url, config, request);
    request.path = url;
  } else {
    // url中是否包含platform参数，有platform参数
    if (url.indexOf('platform') == -1) {
      var platformName = ''; // app

      if (isFromApp()) {
        // ios
        if (detectUtil.os.ios) {
          platformName = 'ios';
        } // android
        else if (detectUtil.os.android) {
            platformName = 'android';
          }
      } else {
        // 微信
        if (isFromWeiXin()) {
          platformName = 'weixin';
        } // 其他端
        else {
            platformName = 'other';
          }
      }

      if (url.match('[\?]')) {
        url += '&platform=' + platformName;
      } else {
        url += '?platform=' + platformName;
      }
    }

    request.path = url;
  } // 对entityParams做restful变量处理


  var entityParams = extendsUtil({}, request.entity, ticketGenerator());

  for (var key in entityParams) {
    if (/:\w+/.test(key)) {
      request.path = request.path.replace(eval("/" + key + "/g"), entityParams[key]);
      delete entityParams[key];
    }
  }

  request.entity = entityParams;
  return request;
};

var restTransformInterceptor = interceptor({
  /**
   * @field funcNo {string} 调用中台的功能号，用于应用层路由
   * @field messageEntity {object/string} 消息体，可能是一个字符串也可能是一个对象
   *
   * @class config
   */
  init: function init(config) {
    return config;
  },
  request: function request(_request, config) {
    return warpMessageEntity$1(_request, config);
  },
  response: function response(_response, config) {
    return _response;
  }
});

/**
 * Created by dfzq on 2017/4/18.
 */
var appAuthorizeInterceptor = interceptor({
  init: function init(config) {
    return config;
  },
  request: function request(_request, config) {
    // // 授权机制 //
    // if (!!AppAuthorize.token)
    // {
    //     request.entity.header.token = AppAuthorize.token;
    // }
    // if (!!AppAuthorize.vtDeviceId)
    // {
    //     request.entity.header.vtDeviceId = AppAuthorize.vtDeviceId;
    // }
    // 授权机制调整，修改为恢复机制
    if (!!AppAuthorize$1.token) {
      _request.entity.header.token = AppAuthorize$1.token;
    } else {
      AppAuthorize$1.token = store.get(configuration.tokenKey);
      _request.entity.header.token = AppAuthorize$1.token;
    }

    if (!!AppAuthorize$1.vtDeviceId) {
      _request.entity.header.vtDeviceId = AppAuthorize$1.vtDeviceId;
    } else {
      AppAuthorize$1.vtDeviceId = store.get(configuration.vtDeviceIdKey);
      _request.entity.header.vtDeviceId = AppAuthorize$1.vtDeviceId;
    }

    return _request;
  },
  response: function response(_response, config) {
    return _response;
  }
});

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = ".style_wt-alert__1lMea .style_modal-content__3AFYW {\n  border-radius: 4px;\n  overflow: hidden; }\n\n.style_wt-alert__1lMea .style_modal-dialog__17JtU {\n  margin-top: 15%; }\n\n.style_wt-alert__1lMea .style_modal-body__2FycO {\n  display: table-cell;\n  vertical-align: middle;\n  height: 158px;\n  min-height: 158px;\n  width: 350px;\n  min-width: 350px;\n  font-size: 16px;\n  color: #343434;\n  letter-spacing: 0;\n  text-align: left;\n  padding: 45px; }\n\n.style_wt-alert__1lMea .style_modal-footer__2B7Vp {\n  padding: 0; }\n  .style_wt-alert__1lMea .style_modal-footer__2B7Vp button {\n    float: left;\n    height: 56px;\n    border: none;\n    border-radius: 0;\n    width: 100%;\n    padding: 0;\n    font-size: 16px;\n    color: #999999;\n    letter-spacing: 0;\n    text-align: center; }\n  .style_wt-alert__1lMea .style_modal-footer__2B7Vp button + button {\n    color: #343434;\n    font-weight: bold;\n    margin: 0;\n    border-left: 1px solid #e5e5e5; }\n  .style_wt-alert__1lMea .style_modal-footer__2B7Vp .style_btn__3HxjO + .style_btn__3HxjO {\n    margin: 0; }\n\n.style_wt-alert__1lMea .style_wrap__1OENM {\n  text-align: center;\n  width: 100%;\n  height: 128px; }\n\n.style_wt-alert__1lMea .style_wrap__1OENM:before {\n  content: '';\n  display: inline-block;\n  height: 100%;\n  vertical-align: middle; }\n\n.style_wt-alert__1lMea .style_wrap__1OENM .style_content__10eEf {\n  max-width: 97%;\n  display: inline-block;\n  vertical-align: middle; }\n\n@media (min-width: 768px) {\n  .style_wt-alert__1lMea .style_modal-dialog__17JtU {\n    width: 350px; } }\n";
styleInject(css_248z);

/*
 * @Author: YangJiaqi
 * @Date: 2019-11-06 13:32:59
 * @Company: orientsec.com.cn
 * @Description:
 */
function wtAlert (_ref) {
  var content = _ref.content,
      _ref$buttonText = _ref.buttonText,
      buttonText = _ref$buttonText === void 0 ? "确定" : _ref$buttonText,
      buttonHandler = _ref.buttonHandler,
      _ref$extraClassName = _ref.extraClassName,
      extraClassName = _ref$extraClassName === void 0 ? "" : _ref$extraClassName;
  var template = "\n<div class=\"wt-alert fade modal ".concat(extraClassName, "\" tabindex=\"-1\" role=\"dialog\">\n  <div class=\"modal-dialog\" role=\"document\">\n    <div class=\"modal-content\">\n      <div class=\"modal-body\">\n        <div>").concat(content, "</div>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">").concat(buttonText, "</button>\n      </div>\n    </div>\n  </div>\n</div>");
  var $template = $(template);
  buttonHandler && $template.find("button").on("click", buttonHandler);
  $template.modal({
    show: true,
    backdrop: "static"
  });
  return $template;
}

var BIZ_SUCCESS_CODE = 0,
    // 业务处理超时
BIZ_TIMEOUT_CODE = 7100;
var parseErrorInterceptor = interceptor({
  init: function init(config) {
    return config;
  },
  request: function request(_request, config) {
    return _request;
  },
  response: function response(_response, config) {
    if (_response.error) {
      return _response;
    }

    _response.entity = _response.entity && _typeof(_response.entity) === 'object' ? _response.entity : JSON.parse(_response.entity);

    if (_response.entity.hasOwnProperty('code')) {
      if (_response.entity.code == BIZ_SUCCESS_CODE) {
        return _response;
      } else if (_response.entity.code == BIZ_TIMEOUT_CODE) {
        return when.reject({
          response: _response,
          error: 'biztimeouterror'
        });
      } else {
        return when.reject({
          response: _response,
          error: 'serverexceptionerror'
        });
      }
    }

    return _response;
  }
});

/*
 * @Author: shenzhiwei
 * @Date: 2019-11-15 08:56:53
 * @Company: orientsec.com.cn
 * @Description: 对输出进行解耦化，更易于单元测试
 */
/**
 * 消息体再封装
 * @param response API响应消息体
 */

function wrapResponse (response) {
  var state = false,
      unionAuth = false,
      code = -1,
      info = 'network error',
      timestamp = Date.parse(new Date()); // 2020-12-23:兼容response出现2层的缺陷

  if (response.entity === undefined && !!response.response) {
    var respProxy = {
      error: response.error,
      response: response.response
    };
    response = respProxy.response;
    response.error = respProxy.error;
    respProxy = null;
  }

  if (response.entity) {
    if (response.entity.header) {
      state = response.entity.header.state; // 增加第三方渠道授权状态

      unionAuth = response.entity.header.unionAuth;
      timestamp = response.entity.header.timestamp;
    }

    if (response.entity.payload) {
      code = response.entity.payload.code;
      info = response.entity.payload.info;
    } else {
      code = response.entity.code;
      info = response.entity.info;
    }
  } // 只有通讯出现错误才会有error字段


  var error = 'businesserror';

  if (response.error) {
    error = response.error;
  } // 对timestamp做处理


  var sysdate = null,
      sysyear = null,
      sysmonth = null,
      sysday = null;

  try {
    sysdate = new Date(parseInt(timestamp));
    sysyear = sysdate.getFullYear();
    sysmonth = sysdate.getMonth() + 1;
    sysday = sysdate.getDate();
  } catch (e) {
    sysdate = null;
    sysyear = null;
    sysmonth = null;
    sysday = null;
  } // 对wrap数据进行重新包装


  var data = {};
  var header = {
    header: {
      state: state,
      unionAuth: unionAuth,
      code: code,
      info: info,
      timestamp: timestamp,
      sysdate: sysdate,
      sysyear: sysyear,
      sysmonth: sysmonth,
      sysday: sysday
    } // code: code,
    // info: info,
    // error: error,

  }; // 解决接口输出中包含code和info关键字的bug
  // 业务接口执行失败才追加code和info

  if (code != '0') {
    header.code = code;
    header.info = info;
    header.error = error;
  }

  if (response.entity) {
    return extendsUtil(data, response.entity.payload ? response.entity.payload.data : response.entity.data, header);
  } else {
    return header;
  }
}

/*
 * @Author: linyiqing
 * @Date: 2019-10-15 13:54:15
 * @Company: orientsec.com.cn
 * @Description: 
 */

var rFlag = false;
var ua = navigator.userAgent;
var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
/**
 * 执行原生登录指令
 * @param successCallback 成功回调，只会有成功回调，失败由原生自己实现
 */

var login = function login(successCallback) {
  var wrap = function wrap(resp) {
    // 加强逻辑，提前进行token的刷新，增加容错性
    if (resp.token) {
      // 同时刷新AppAuthorize中的token
      AppAuthorize$1.token = resp.token;
      store.set(configuration.tokenKey, resp.token);
    }

    console.log('[NativeLogin refreshToken]：' + JSON.stringify(resp));
    WebViewJavascriptBridge.callHandler('refreshToken', {}, function (response) {
      console.log('[refreshToken]：' + JSON.stringify(response));

      if (typeof response == 'string') {
        response = JSON.parse(response);
      } // 成功处理


      if (response.code == '0') {
        // 2020-12-29: 增加 refreshToken 处理
        var IF018020Resp = {};

        if (!isEmpty(response.refreshTokenJson)) {
          if (typeof response.refreshTokenJson === "string") {
            IF018020Resp = JSON.parse(response.refreshTokenJson);
          }
        } // 同步并刷新最新的服务端loginUser，可能是资金账户或手机号


        if (!!IF018020Resp.loginUser) {
          AppAuthorize$1.loginUser = IF018020Resp.loginUser;
        } // 同步并刷新最新的服务端refreshToken


        if (!!IF018020Resp.refreshToken) {
          AppAuthorize$1.refreshToken = IF018020Resp.refreshToken;
        } // 同步并刷新最新的服务端logon


        if (!!IF018020Resp.logon) {
          AppAuthorize$1.logon = IF018020Resp.logon;
        } // 为APP授权模块标志授权标识token和虚拟设备ID


        AppAuthorize$1.token = response.token; // 同步并刷新最新的服务端token

        if (!!IF018020Resp.token) {
          AppAuthorize$1.token = IF018020Resp.token;
        }

        AppAuthorize$1.vtDeviceId = response.vtDeviceId; // 账户类信息授权

        AppAuthorize$1.clientType = response.auth.clientType; // 同步并刷新最新的服务端clientType

        if (!!IF018020Resp.clientType) {
          AppAuthorize$1.clientType = IF018020Resp.clientType;
        }

        AppAuthorize$1.fundAccount = response.auth.fundAccount;
        AppAuthorize$1.regAccount = response.auth.regAccount; // 同步并刷新最新的服务端regAccount

        if (!!IF018020Resp.regAccount) {
          AppAuthorize$1.regAccount = IF018020Resp.regAccount;
        }

        AppAuthorize$1.bizSysId = response.auth.bizSysId;
        AppAuthorize$1.clientName = response.auth.clientName == '' || response.auth.clientName == null ? '-' : response.auth.clientName; // 增加authSign（服务端通过该字段进行会话脏数据检查）

        AppAuthorize$1.authSign = isEmpty(response.authSign) ? '' : response.authSign; // 刷新并覆盖原来可能失效的授权凭证token

        store.set(configuration.tokenKey, AppAuthorize$1.token); // 同时刷新vtDeviceId(用于机制调整后的恢复)

        store.set(configuration.vtDeviceIdKey, response.vtDeviceId);

        if (typeof successCallback === 'function') {
          successCallback(resp);
        }
      } // 失败处理
      else {
          alert('似乎网络开小差了!');
        }
    });
  };

  if (WebViewJavascriptBridge) {
    WebViewJavascriptBridge.callHandler('request', {
      type: '2',
      payload: {
        type: '2'
      }
    }, function (response) {
      console.log('[NativeLogin Module] ios sync callout');

      if (typeof response == 'string') {
        response = JSON.parse(response);
      } // 防止安卓指令调用成功同步进入的控制


      if (ipad || iphone || ipod || response.payload) {
        wrap(response.payload);
      }
    }); // 安卓端采用异步通知，在此进行登录成功的事件订阅

    if (!rFlag) {
      WebViewJavascriptBridge.registerHandler('request', function (response) {
        console.log('[NativeLogin Module] android async callout');

        if (typeof response == 'string') {
          response = JSON.parse(response);
        }

        if (!response.error || response.error === 'false') {
          wrap(response.payload);
        }
      });
      rFlag = true;
    }
  }
};

var httpRequestClient = httpClient(); // 将httpRequestClient(该实例被声明为一个单例实例)实例暴露为window作为全局实例，让websocket在mock环境下直接使用该实例

window.httpRequestClient = httpRequestClient; // 防止3xxx发生时重复弹出登录确认框(修改为全局变量，提供给重构后的consumedService使用)
// let alertRepeatLoginFlag = false

window.alertRepeatLoginFlag = false; // 防重弹框黑名单

window.repeatAlertBlackList = []; // 增加简化版的原生登录处理
/**
 * 定义API的功能号和输入参数、统一业务错误(即特殊业务错误码,如3000区间为未登录的错误码区段)的函数回调闭包
 * @param funcNo            接口功能号
 * @param messageEntity     接口输入参数结构
 * @param onError           统一业务错误的函数回调定义，如果调用者需要捕获处理
 * @param onAuthError       统一授权错误的函数回调定义，例如发生3xxx的未登录授权错误
 */

var api = (function (funcNo, messageEntity, onError, onAuthError) {
  if (!messageEntity || typeof messageEntity === 'function') {
    messageEntity = {};
  } // // 检查网络状态
  // networkCheck()


  return when.attempt(function (obj) {
    if (obj && _typeof(obj) === 'object') {
      return obj;
    } else {
      return JSON.parse(obj);
    } // obj && typeof obj === 'object' ? obj : JSON.parse(obj)

  }, messageEntity).otherwise(function (_) {
    throw '中台消息体序列化时发生错误';
  }).then(function (entity) {
    // 需要在base.js中定义接口的相关特性
    var api = configuration.api[funcNo]; // 如果未在配置文件(基类)中明确定义则采用默认配置，此处今后可扩展api的额外属性

    if (!api) {
      // 默认配置
      var defaultAPIConfig = {
        path: 'path'
      };
      api = extendsUtil({}, api, defaultAPIConfig);

      if (!configuration.api[funcNo]) {
        configuration.api[funcNo] = api;
      }
    } // 消息体是否加解密


    var _encryptAPIFlag = (configuration['encryptAPIList'] || []).indexOf(funcNo);

    var _noEncryptAPIFlag = (configuration['noEncryptAPIList'] || []).indexOf(funcNo); // 当配置项encryptAPIList和noEncryptAPIList同时配置(避免互斥)或者都没有配置，则读取全局加解密配置项


    var isEncryptFlag = true;

    if (_encryptAPIFlag < 0 && _encryptAPIFlag == _noEncryptAPIFlag || _encryptAPIFlag >= 0 && _noEncryptAPIFlag >= 0) {
      isEncryptFlag = (configuration[api.path + 'Encrypt'] == undefined ? true : configuration[api.path + 'Encrypt']) ? true : false;
    } else {
      isEncryptFlag = _encryptAPIFlag > _noEncryptAPIFlag ? true : false;
    } // 对httpClient进行拦截操作
    // 先进行数据转化，后执行序列化；否则字符串无法进行数据转化


    var client = httpRequestClient.addInterceptor(errorcodeHandler); // 异常结构处理(只有加密模式才拦截进行处理，该拦截器的作用防止服务端因无法解析加密报文而无法返回加密后的响应)

    if (isEncryptFlag) {
      client = client.addInterceptor(parseErrorInterceptor, {
        funcNo: funcNo
      });
    }

    client = client.addInterceptor(timeoutHandler, {
      timeout: configuration.timeout
    });

    if (isEncryptFlag) {
      client = client.addInterceptor(securityInterceptor, {
        funcNo: funcNo
      });
    }

    client = client.addInterceptor(mimeHandler, {
      mime: 'application/json'
    }); // 增加日志记录模块

    client = client.addInterceptor(logInterceptor, {
      funcNo: funcNo
    }); // 多端化处理，针对app和微信渠道
    // ios/android端且是webview容器

    if (detectUtil.os.ios || detectUtil.os.android) {
      // 必须webview容器，不然jsapi不会生效
      if (isFromApp()) {
        client = client.addInterceptor(appAuthorizeInterceptor, {
          funcNo: funcNo
        });
      } // 微信端不增加虚拟设备号

    } // 组织消息body结构


    if (/^IF\d{6}$/.test(funcNo)) {
      // IF+6位数字风格功能号
      client = client.addInterceptor(transformInterceptor, {
        funcNo: funcNo
      });
    } else {
      // restful风格功能号
      client = client.addInterceptor(restTransformInterceptor, {
        funcNo: funcNo
      });
    }

    return when.promise(function (resolve, reject) {
      client({
        //path: path,       // 由transformHandler实现定义
        method: 'POST',
        entity: entity,
        headers: {
          'Content-Type': 'application/json'
        },
        xhrFields: {
          // 本地Ip和Localhost不配置credentials资源共享
          withCredentials: /^((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)$/.test(location.hostname) || location.hostname === 'localhost' ? false : true
        }
      }).then(function (response) {
        // 包装消息体
        var data = wrapResponse(response);
        var _data$header = data.header,
            code = _data$header.code,
            info = _data$header.info; // 是否服务端会话过期
        // linyiqing 20200110 去掉3111错误码，那个是解码错误

        var isServerSessionExpired = code >= 3000 && code <= 3019 || code === 3030 || code === 10026 || code === 5200; // 设计问题，对unionAuth字段不进行处理 2018-3-31
        // // 微信端处理（第三方授权状态验证）
        // let isOauthCheckFlag = getQueryString('oa')     // 当oa=0不进行授权状态验证逻辑
        // if (configuration.appEnv != 'mock') {
        //     if (isFromWeiXin()) {
        //         if(isOauthCheckFlag != '0'){
        //             if (!data.header.unionAuth) {
        //                 // 关闭加载指示器
        //                 hideLoading()
        //                 // 提示用户将进行重定向到长链
        //                 toast('微信授权已过期!', 1500)
        //                 setTimeout(_ => {
        //                     // 清除tokenStorage
        //                     store.remove(configuration.tokenKey)
        //
        //                     location.href = oauthUri(createHref('../account-myaccount/index.html'))
        //                 }, 1500)
        //                 return
        //             }
        //         }
        //     }
        // }
        // 业务错误或者http错误抛出reject

        if (code === 0) {
          resolve(data);
        } // 处理1XXX错误(会回调reject)
        else if (code >= 1000 && code <= 1999) {
            // if (typeof onError === 'function') {
            //     data.error = 'serviceerror'
            //     onError(response, data)
            // }
            // else {
            //   reject(data)
            // }
            data.error = 'serviceerror';
            reject(data);
          } // 处理授权类错误3000-3019(需要再次登录认证)
          else if (isServerSessionExpired) {
              // 清除tokenStorage
              store.remove(configuration.tokenKey); // 清除归档数据(微信端不做清除，因为还可以通过微信授权恢复账户权限相关信息)

              if (!isFromWeiXin()) {
                AppAuthorize$1.unarchive();
              }

              data.error = 'autherror';

              if (typeof onAuthError === 'function') {
                onAuthError(response, data);
              } else {
                reject(data);
              } // 关闭加载指示器


              hideLoading();

              if (typeof onAuthError !== 'function') {
                if (!alertRepeatLoginFlag) {
                  alertRepeatLoginFlag = true; // linyiqing 20200107 增加网厅的默认处理：跳登录

                  if (APPTYPE == 'wangting') {
                    wtAlert({
                      content: info,
                      buttonHandler: function buttonHandler() {
                        alertRepeatLoginFlag = false;
                        location.href = "../wt-login/index.html";
                      }
                    });
                  } else {
                    // 20201103: 新增页面过期检测处理，只要页面侧做好严格的长短登录控制，一旦长时间未操作会触发服务端会话过期重复登录操作
                    // 为了避免这个场景的出现，因此新增该处理来优化一旦发生，让用户退出重新通过oauth恢复会话态，而不用重复进行原生登录
                    var info_ = info;
                    var btnText_ = "登录";

                    if (window.pageExpiredSwitch && isFromApp()) {
                      info_ = "由于您长时间未进行任何操作，出于安全保护请退出后重新访问该功能";
                      btnText_ = "确认";
                    } // linyiqing 20191011 统一弹框的按钮文案改成“登录”


                    alert({
                      text: info_,
                      onClick: function onClick() {
                        alertRepeatLoginFlag = false;
                        var loginAuthorizationUrl = createHref('../account-login2/index.html', location.href); // APP端

                        if (isFromApp()) {
                          if (window.pageExpiredSwitch) {
                            window["WebViewJavascriptBridge"].callHandler('back', {}, function (response) {});
                          } else {
                            // LoginFailureCompatible
                            if (compareVersion("4.3.0") >= 0 && compareVersion("4.6.0") < 0) {
                              if (window.onLoginFailureCompatible) {
                                window.onLoginFailureCompatible();
                              }
                            } else {
                              // 执行原生login指令 ...
                              login(function (_) {
                                // 成功发送通知
                                if (window.onNativeClient30XXLoginSuccessed) {
                                  window.onNativeClient30XXLoginSuccessed();
                                }
                              });
                            }
                          }
                        } // 微信端
                        else if (isFromWeiXin()) {
                            location.href = loginAuthorizationUrl;
                          } // 其他渠道，例如其他web浏览器或手机浏览器
                          else {
                              location.href = loginAuthorizationUrl;
                            }
                      },
                      modalButtonOk: btnText_
                    });
                  }
                }
              }
            } // 防重复alert黑名单控制，请开发者将需要防重的错误码填写在下方，系统不会弹出多次同样的弹框报错
            else if (code == 7001 || code == 1509) {
                if (window.repeatAlertBlackList.indexOf(code) === -1) {
                  window.repeatAlertBlackList.push(code);
                  alert({
                    text: info,
                    onClick: function onClick() {
                      window.repeatAlertBlackList = [];
                    }
                  });
                  reject({
                    error: "autherror"
                  });
                }
              } // 其它业务异常或未知异常
              else {
                  reject(data.header);
                }
      }).otherwise(function (response) {
        var data = wrapResponse(response);

        if (!data.code) {
          data.code = -1;
        } // httpcode异常，例如404，500


        if (response.error === 'httperror') {
          data.error = 'httperror';
          data.info = '网络通讯出现错误';
        } // 客户端网络超时检测
        else if (response.error === 'timeout') {
            data.error = 'timeouterror';
            data.info = '连接超时请检查网络设置';
          } // 服务端业务处理超时
          else if (response.error === 'biztimeouterror') {
              data.error = 'biztimeouterror';
              data.info = '网络调用超时';
            } // 客户端和服务端之间消息加解密发生错误
            else if (response.error === 'encrypterror') {
                data.error = 'encrypterror';
                data.info = '加解密时发生错误';
              } // 对消息真实性进行验签
              else if (response.error === 'signerror') {
                  data.error = 'signerror';
                  data.info = '验证签名时发生错误';
                } // 服务端异常处理
                else if (response.error === 'serverexceptionerror') {
                    data.error = 'serverexceptionerror';
                    data.info = "\u670D\u52A1\u53D1\u751F\u5F02\u5E38(".concat(data.code, ")");
                  } // 未知异常
                  else {
                      data.error = 'unknownerror';
                      data.info = '系统发生未知异常';
                    }

        tip({
          content: data.info,
          stayTime: 3500,
          type: "warn"
        });
        hideLoading(); // if (typeof onError === 'function')
        // {
        //     data.header.info = data.info
        //     onError(response, data)
        // }

        reject(data);
      });
    });
  });
});

var IF156008 = (function (onError, onAuthError) {
  return api('IF156008', {}, onError, onAuthError);
});

/*
 * @Author: shenzhiwei
 * @Date: 2019-08-03 18:22:52
 * @Company: orientsec.com.cn
 * @Description: 恢复微信存储在localstorage中的用户信息，由于某种原因丢失这部分数据
 */
var storeWxLocalstorage = (function (callback) {
  if (AppAuthorize$1.needStore()) {
    IF156008(function (_) {}, function (resp) {
      // 当出现登录态失效时，该接口不做任何处理
      console.log('IF156008不做登录态检查'); // 恢复标识设置为true

      AppAuthorize$1.storeFlag = true;
      AppAuthorize$1.archive();
      callback();
    }).then(function (resp) {
      console.log('恢复微信用户信息 ... '); // 归档用户微信用户信息 //

      AppAuthorize$1.loginMethod = resp.loginChannel;
      AppAuthorize$1.clientType = resp.clientType;
      AppAuthorize$1.loginUser = resp.loginUser;
      AppAuthorize$1.storeFlag = true;
      AppAuthorize$1.archive(); //////////////////////

      console.log("\u5FAE\u4FE1\u7528\u6237\u8D26\u6237[".concat(AppAuthorize$1.loginUser, "] \u767B\u5F55\u6E20\u9053[").concat(AppAuthorize$1.loginMethod, "] \u5BA2\u6237\u7C7B\u578B[").concat(AppAuthorize$1.clientType, "]"));
      callback();
    }).otherwise(function (err) {
      console.log('恢复微信用户信息时出错：' + err); // 如果该接口调用失败，直接回调上层，不做任何处理

      callback();
    });
  } else {
    callback();
  }
});

/*
 * @Author: shenzhiwei
 * @Date: 2021-01-05 16:05:41
 * @Company: orientsec.com.cn
 * @Description: 
 */
var versionList = {
  "request9": "4.7.0",
  "request9.object.mode": "4.7.0",
  "request9.success.cardId": "4.7.0",
  "request9.success.name": "4.7.0",
  "request9.success.sex": "4.7.0",
  "request9.success.address": "4.7.0",
  "request9.success.nation": "4.7.0",
  "request9.success.birth": "4.7.0",
  "request9.success.office": "4.7.0",
  "request9.success.validityPeriod": "4.7.0",
  "request9.success.frontData": "4.7.0",
  "request9.success.backData": "4.7.0",
  "request9.error.info": "4.7.0",
  "request1": "0.0.0",
  "request1.object.type": "0.0.0",
  "request1.object.fundAccount": "3.2.7",
  "request1.object.fundtype": "3.9.3",
  "request1.success.isLogin": "0.0.0",
  "request1.success.clientName": "3.2.7",
  "request1.success.fundAccount": "3.2.7",
  "request1.success.bizSysId": "3.9.3",
  "request2": "0.0.0",
  "request2.success.token": "0.0.0",
  "request2.success.vtDeviceId": "0.0.0",
  "request2.success.loginAccount": "4.3.0",
  "request2.success.loginType": "4.3.0",
  "request2.success.auth.clientType": "0.0.0",
  "request2.success.auth.bizSysId": "0.0.0",
  "request2.success.auth.clientName": "0.0.0",
  "request2.success.auth.fundAccount": "0.0.0"
};

var OPENID = 'openid';
var NICKNAME = 'nickname';
var isRegisterOk = false; // // appear最近一次执行的毫秒数
/**
 * 查询API是否兼容
 * @param {*} schema 使用 ${API}.${method}.${param}.${option} 或者 ${component}.${attribute}.${option} 方式来调用
 */

var canIUse = function canIUse(schema) {
  // 如果拿不到APP版本直接标识无法使用该API
  if (!getVersion()) {
    return false;
  }

  if (versionList[schema]) {
    var isSupport = compareVersion(versionList[schema]);

    if (isSupport >= 0) {
      return true;
    }
  }

  return false;
};
/**
 * 启动授权
 * 微信：走微信oauth2授权模式获取微信用户基本信息，例如openid
 * APP：走refreshToken授权模式，获取token和vtDeviceId
 * @param callback 成功处理回调
 * @param failCallback 失败处理回调
 * @constructor
 */


var oauth = function oauth(callback, failCallback) {
  console.log('[jsbridge oauth] callback'); // 微信端处理

  if (isFromWeiXin()) {
    // 获取微信openid授权信息
    if (!AppAuthorize$1.openId) {
      AppAuthorize$1.openId = getQueryString(OPENID);
    }

    if (!AppAuthorize$1.nickName) {
      AppAuthorize$1.nickName = getQueryString(NICKNAME);
    }

    AppAuthorize$1.archive();

    if (typeof callback === 'function') {
      storeWxLocalstorage(callback);
    }
  } // APP端处理
  else if (isFromApp()) {
      // 首先建立js桥接模式
      if (!isRegisterOk) {
        // 是否小于APP 4.11.0 版本
        var isLessThan4110 = compareVersion('4.11.0') < 0; // 注：iOS从4.11.0开始不使用isRegisterOk进行防重发
        // iOS4.11.0前oauth的请求和回调并不是一一对应的，之后的修复成和安卓一样

        var isIOS = detectUtil.os.ios;
        isRegisterOk = isIOS && isLessThan4110;

        if (WebViewJavascriptBridge) {
          WebViewJavascriptBridge.callHandler('refreshToken', {}, function (response) {
            console.log('[jsbridge refreshToken]：' + JSON.stringify(response));

            if (typeof response == 'string') {
              response = JSON.parse(response);
            } // 成功处理


            if (response.code == '0') {
              // 2020-12-29: 增加 refreshToken 处理
              var IF018020Resp = {};

              if (!isEmpty(response.refreshTokenJson)) {
                if (typeof response.refreshTokenJson === "string") {
                  IF018020Resp = JSON.parse(response.refreshTokenJson);
                }
              } // 同步并刷新最新的服务端loginUser，可能是资金账户或手机号


              if (!!IF018020Resp.loginUser) {
                AppAuthorize$1.loginUser = IF018020Resp.loginUser;
              } // 同步并刷新最新的服务端refreshToken


              if (!!IF018020Resp.refreshToken) {
                AppAuthorize$1.refreshToken = IF018020Resp.refreshToken;
              } // 同步并刷新最新的服务端logon，数据类型boolean


              if (IF018020Resp.logon !== undefined) {
                AppAuthorize$1.logon = IF018020Resp.logon;
              } // 为APP授权模块标志授权标识token和虚拟设备ID


              AppAuthorize$1.token = response.token; // 同步并刷新最新的服务端token

              if (!!IF018020Resp.token) {
                AppAuthorize$1.token = IF018020Resp.token;
              }

              AppAuthorize$1.vtDeviceId = response.vtDeviceId; // 账户类信息授权

              AppAuthorize$1.clientType = response.auth.clientType; // 同步并刷新最新的服务端clientType

              if (!!IF018020Resp.clientType) {
                AppAuthorize$1.clientType = IF018020Resp.clientType;
              }

              AppAuthorize$1.fundAccount = response.auth.fundAccount;
              AppAuthorize$1.regAccount = response.auth.regAccount; // 同步并刷新最新的服务端regAccount

              if (!!IF018020Resp.regAccount) {
                AppAuthorize$1.regAccount = IF018020Resp.regAccount;
              }

              AppAuthorize$1.bizSysId = response.auth.bizSysId;
              AppAuthorize$1.clientName = isEmpty(response.auth.clientName) ? '-' : response.auth.clientName; // 增加authSign（服务端通过该字段进行会话脏数据检查）

              AppAuthorize$1.authSign = isEmpty(response.authSign) ? '' : response.authSign; // 刷新并覆盖原来可能失效的授权凭证token

              store.set(configuration.tokenKey, AppAuthorize$1.token); // 同时刷新vtDeviceId(用于机制调整后的恢复)

              store.set(configuration.vtDeviceIdKey, response.vtDeviceId);

              if (typeof callback === 'function') {
                callback();
              }
            } // 失败处理
            else {
                // // alert('似乎网络开小差了!')
                // if (typeof failCallback === 'function') {
                //   failCallback()
                // }
                // 2020-12-29:当网络超时或无网情况下保证页面非白屏展示
                if (typeof callback === 'function') {
                  callback();
                }
              }

            isRegisterOk = false;
          });
        }
      }
    } // 其它端
    else {
        if (typeof callback === 'function') {
          callback();
        }
      }
};

/*
 * @Author: shenzhiwei
 * @Date: 2019-08-17 10:42:32
 * @Company: orientsec.com.cn
 * @Description: 自定义异常处理对象
 */
var CustomError = /*#__PURE__*/function (_Error) {
  _inherits(CustomError, _Error);

  var _super = _createSuper(CustomError);

  function CustomError(msg) {
    _classCallCheck(this, CustomError);

    return _super.call(this, msg);
  }

  _createClass(CustomError, [{
    key: "error",
    value: function error() {
      console.error(this.stack);
    }
  }, {
    key: "warn",
    value: function warn() {
      console.warn(this.stack);
    } // is<T extends typeof CustomError>(exceptionCtor: T) {
    //   return this.name === exceptionCtor.name;
    // }

  }]);

  return CustomError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * 异常字典
 */

var Exception;

(function (Exception) {
  Exception["AuthException"] = "AuthException";
  Exception["BusinessException"] = "BusinessException";
  Exception["EncryptException"] = "EncryptException";
  Exception["HttpException"] = "HttpException";
  Exception["RuntimeException"] = "RuntimeException";
  Exception["SerializableException"] = "SerializableException";
  Exception["ServerException"] = "ServerException";
  Exception["ServiceException"] = "ServiceException";
  Exception["ServiceTimeoutException"] = "ServiceTimeoutException";
  Exception["SignException"] = "SignException";
  Exception["TimeoutException"] = "TimeoutException";
  Exception["OAuthException"] = "OAuthException";
  Exception["UnknownException"] = "UnknownException";
  Exception["CancelException"] = "CancelException";
})(Exception || (Exception = {}));

/**
 * 服务端鉴权发生异常时的错误处理对象
 */

var AuthException = /*#__PURE__*/function (_CustomError) {
  _inherits(AuthException, _CustomError);

  var _super = _createSuper(AuthException);

  function AuthException(msg, code) {
    var _this;

    _classCallCheck(this, AuthException);

    _this = _super.call(this, msg);
    _this.code = void 0;
    _this.name = Exception.AuthException;
    _this.code = code || -1; // super.warn();

    return _this;
  }

  return AuthException;
}(CustomError);

/**
 * OAuth鉴权基础服务，提供性能优秀的鉴权机制
 */

var OAuthService = /*#__PURE__*/function () {
  _createClass(OAuthService, [{
    key: "consume",
    //#region public methods

    /**
     * （异步执行）消费user service(即消费服务方)
     * 作用：执行并转化为Service的原始输出类型
     */
    value: function consume() {
      var _this = this;

      // 向消费服务方(consumedService)消费local token，如果消费成功则直接then
      if (!this.localTokenConsumed && isFromApp()) {
        log("begin to consume local token"); // local token未消费
        // 阻止api默认鉴权行为

        this.preventApiDefaultBehavior(true);
        return this.consumedService.apply(this, _toConsumableArray(this.consumedServiceArgs[0])).then(function (res) {
          log("success to consume local token");

          _this.preventApiDefaultBehavior(false);

          return res;
        }).catch(function (exception) {
          _this.preventApiDefaultBehavior(false);

          if (exception.name === AuthException.name) {
            log("fail to consume local token");
            _this._localTokenConsumed = true;
            log("begin to consume client token");
            return _this.clientConsume();
          } // 当发生其它异常情况时，local token消费标识不需要更新，直接抛给上层调用即可，流程提前结束


          log("success to consume local token:" + exception.message);
          throw exception;
        });
      } else {
        log("begin to consume client token only"); // local token已消费

        return this.clientConsume();
      }
    } //#endregion
    //#region private methods

    /**
     * 调用oauth获取客户端的client token进行消费
     * 注：该函数返回类型必须与消费服务方的返回类型保持一致
     */

  }, {
    key: "clientConsume",
    value: function clientConsume() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        oauth(function () {
          log("success to consume client token");
          _this2.clientTokenConsumed = true; // 使用OAuth刷新后的client token进行再次消费

          resolve(_this2.consumedService.apply(_this2, _toConsumableArray(_this2.consumedServiceArgs[0])));
        });
      });
    }
    /**
     * 阻止api默认行为（如鉴权时的默认弹框）
     * @param isPrevent 是否阻止，true-阻止；false-不阻止
     */

  }, {
    key: "preventApiDefaultBehavior",
    value: function preventApiDefaultBehavior(isPrevent) {
      window["alertRepeatLoginFlag"] = isPrevent;
    } //#endregion

    /**
     * 构建OAuth实例，返回一个与consumer一样类型的promise对象
     * @param consumedService 消费服务方
     * @param consumedServiceArgs 消费服务方的参数
     */

  }, {
    key: "localTokenConsumed",

    /**
     * local token的消费标识
     */

    /**
     * local token的消费标识，默认为false
     */
    get: function get() {
      // // 如果local token为null，代表可能是第一次访问或还未归档完成
      // // 此时的token并没有必要向服务端去消费，因为此时认为这是一个无效的token，因此我们可认为local token已被消费，直接进行后续流程。
      // if (!this.localToken) {
      //   this._localTokenConsumed = true;
      // }
      // return this._localTokenConsumed;
      // 由于退出后的token只会在15分钟后失效（中台设计缺陷），因此只能默认为localToken被消费了直接走clientToken消费流程
      return true;
    }
    /**
     * 鉴权用token凭证，用于服务端的通信安全调用
     */

  }, {
    key: "localToken",

    /**
     * 鉴权用token凭证，用于服务端的通信安全调用
     */
    get: function get() {
      this._localToken = store.get(configuration.tokenKey);
      return this._localToken;
    }
    /**
     * client token的消费标识，默认为false
     */

  }]);

  function OAuthService(consumedService) {
    _classCallCheck(this, OAuthService);

    this._localTokenConsumed = void 0;
    this._localToken = void 0;
    this.clientTokenConsumed = void 0;
    this.consumedServiceArgs = void 0;
    this._localTokenConsumed = false;
    this.clientTokenConsumed = false;

    for (var _len = arguments.length, consumedServiceArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      consumedServiceArgs[_key - 1] = arguments[_key];
    }

    this.consumedServiceArgs = consumedServiceArgs;
  }

  return OAuthService;
}();

/**
 * 业务发生异常时的错误处理对象
 */

var BusinessException = /*#__PURE__*/function (_CustomError) {
  _inherits(BusinessException, _CustomError);

  var _super = _createSuper(BusinessException);

  function BusinessException(msg, code) {
    var _this;

    _classCallCheck(this, BusinessException);

    _this = _super.call(this, msg);
    _this.code = void 0;
    _this.name = Exception.BusinessException;
    _this.code = code || -1; // super.warn();

    return _this;
  }

  return BusinessException;
}(CustomError);

/**
 * 未知异常
 */

var UnknownException = /*#__PURE__*/function (_CustomError) {
  _inherits(UnknownException, _CustomError);

  var _super = _createSuper(UnknownException);

  function UnknownException(msg, code) {
    var _this;

    _classCallCheck(this, UnknownException);

    _this = _super.call(this, msg);
    _this.code = void 0;
    _this.name = Exception.UnknownException;
    _this.code = code || -1; // super.warn();

    return _this;
  }

  return UnknownException;
}(CustomError);

/**
 * Effect基类 - 桥接兼容
 */

var BaseBridgeCompat = /*#__PURE__*/function () {
  /**
   * Effect基类 构造函数
   * @param mutationService mutation基础服务代理
   */
  function BaseBridgeCompat(mutationService) {
    _classCallCheck(this, BaseBridgeCompat);
  } //#region public methods

  /**
   * 长登录
   * 原生端使用request2指令；web端则直接跳转h5登录页面
   */


  _createClass(BaseBridgeCompat, [{
    key: "longLogin",
    value: function longLogin() {
      return canIUse("request2") ? this.nativeLongLogin().then(function (res) {
        // 20201030:新增longShortLogin指令时去除了一级登录返回上一页的操作，当时返回上一页可能是为了避免在对oauth进行重复调用
        // if (res.loginType && res.loginType != "0") {
        //   this.mutationService.select().jsbridge.back();
        // }
        return res;
      }) : this.webLongLogin();
    }
    /**
     * 创建一个Auth服务订阅方，并定义你的服务消费方来进行授权消费，从而获取到安全且高效的鉴权机制
     * ~~~
     * // example code:
     * // yourService:
     * public yourService(a: number, b: string, c: boolean) {
     *    return Promise.resolve();
     * }
     * // 创建一个Auth服务订阅方:
     * this.AuthRenew(yourService, 1, "2", true).then().catch()
     * ~~~
     * @param consumer 服务消费方，必须遵循(...args: any[]) => Promise<T>类型
     * @param args 服务消费方的入参列表
     */

  }, {
    key: "AuthRenew",
    value: function AuthRenew(consumer) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var oauthService = new OAuthService(consumer, args);
      return oauthService.consume();
    } //#endregion
    //#region private methods

    /**
     * (原生端）长登录
     * 调用request2指令
     */

  }, {
    key: "nativeLongLogin",
    value: function nativeLongLogin() {
      window["isRequestLogin"] = true;
      return new Promise(function (resolve, reject) {
        // [4.3.0, 4.6.0): 自动客户端登录
        // 其它版本: 强制客户端登录
        var payload = compareVersion("4.6.0") >= 0 ? {
          type: "2"
        } : "";
        onRequest("2", payload, function (res) {
          // >=4.3.0才会进行success和error回调
          resolve(res);
        }, function (res) {
          if (res.info) {
            var businessException = new BusinessException(res.info);
            reject(businessException);
          } else {
            var unknownException = new UnknownException("原生端登录组件(request2)发生未知异常");
            reject(unknownException);
          }
        });
      }); // 由于版本过多，返回数据结构可能不同，可能会出现序列化失败的情况
      // .then(resJson => {
      //   try {
      //     return deserialize(resJson, LongLoginResponse);
      //   } catch (error) {
      //     throw new SerializableException(
      //       "原生端登录组件(request2)序列化时发生错误"
      //     );
      //   }
      // });
    }
    /**
     * (web端）长登录
     */

  }, {
    key: "webLongLogin",
    value: function webLongLogin() {
      return new Promise(function (resolve, reject) {
        alert("由于您长时间没有登录，请重新登录", function () {
          resolve(Promise.resolve().then(function () {
            var _url = createHref("/account-login2/index.html", location.href);

            location.href = _url;
            return {};
          }));
        });
      });
    } //#endregion

  }]);

  return BaseBridgeCompat;
}();

/**
 * 用户手动取消
 */

var CancelException = /*#__PURE__*/function (_CustomError) {
  _inherits(CancelException, _CustomError);

  var _super = _createSuper(CancelException);

  function CancelException(msg, code) {
    var _this;

    _classCallCheck(this, CancelException);

    _this = _super.call(this, msg);
    _this.code = void 0;
    _this.name = Exception.CancelException;
    _this.code = code || -1; // super.warn();

    return _this;
  }

  return CancelException;
}(CustomError);

/*
 * @Author: tangyu
 * @Date: 2021-01-06 8:23:25
 * @Company: orientsec.com.cn
 * @Description: 东方赢家APP获取ticket通用模块
 */

var isDfzqAppFirstReady = true; // when api

var IF018023 = function IF018023(_ref) {
  var appId = _ref.appId,
      onError = _ref.onError,
      onAuthError = _ref.onAuthError;
  return api("IF018023", {
    appId: appId
  });
};
/**
 * ready 初始化函数 20210118-解决安卓ready重复调用不执行问题
 * @param {*} callback 
 */


var readyInit = function readyInit(callback) {
  if (isDfzqAppFirstReady) {
    ready(function () {
      isDfzqAppFirstReady = false;
      callback();
    });
  } else {
    callback();
  }
};
/**
 * 调用 IF018023 获取认证凭据(APP)
 * @param {} param0 
 */


var getAppTicket = function getAppTicket() {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$appId = _ref2.appId,
      appId = _ref2$appId === void 0 ? "" : _ref2$appId,
      onError = _ref2.onError,
      onAuthError = _ref2.onAuthError;

  return IF018023({
    appId: appId,
    onError: onError,
    onAuthError: onAuthError
  }).then(function (res) {
    return {
      ticket: res.ticket
    };
  }).otherwise(function (error) {
    var name = error.name,
        code = error.code;
    return Promise.reject({
      code: 1,
      msg: "\u7CFB\u7EDF\u5F02\u5E38(".concat(code, ")")
    });
  });
};
/**
 * 获取AppTicket
 * @param {} params
 */


function index (params) {
  if (!params || !params.appId) {
    throw new Error("appId为必传项");
  }

  console.log('===当前 传入 appId===', params.appId); // 设置默认值

  if (params.cancelIsForceViewExit === undefined) {
    params.cancelIsForceViewExit = false;
  }

  return new Promise(function (resolve, reject) {
    readyInit(function () {
      oauth(function () {
        // 检查当前状态是否是登录态
        AppAuthorize$1.isLongLogin().then(function (isLogin) {
          console.log('===当前 isLongLogin 登录状态===', isLogin); // 登录

          if (isLogin) {
            getAppTicket(params).then(function (resp) {
              return resolve(resp);
            }).otherwise(function (err) {
              return reject(err);
            });
          } else {
            // 未登录,调用一级登录指令
            new BaseBridgeCompat().nativeLongLogin().then(function (res) {
              console.log('===当前 nativeLongLogin res.loginType===', res.loginType); //loginType = 0  取消登录

              if (res.loginType != "0") {
                getAppTicket(params).then(function (resp) {
                  return resolve(resp);
                }).otherwise(function (err) {
                  return reject(err);
                });
              } else {
                // 抛向 otherwise 层处理
                return Promise.reject(new CancelException("用户取消登录"));
              }
            }).catch(function (error) {
              // console.log('===当前 nativeLongLogin error===', error);
              if (error.name === Exception.CancelException) {
                if (params.cancelIsForceViewExit) {
                  onBack();
                } else {
                  reject({
                    code: -1,
                    msg: error.message
                  });
                }
              } else {
                reject({
                  code: 1,
                  msg: "系统异常(唤起登录失败)"
                });
              }
            });
          }
        }).catch(function (error) {
          // console.log('===当前 isLongLogin error===', error);
          reject({
            code: 1,
            msg: "系统异常(IF115000)"
          });
        });
      });
    });
  });
}

export default index;
